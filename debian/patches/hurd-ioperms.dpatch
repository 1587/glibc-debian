#! /bin/sh -e

# All lines beginning with `# DP:' are a description of the patch.
# DP: Support ioperms in oskit-mach

if [ $# -ne 2 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch -d "$2" -f --no-backup-if-mismatch -p1 < $0;;
    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p1 < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

# append the patch here and adjust the -p? flag in the patch calls.
diff -urN glibc-2.2.5.old/ChangeLog glibc-2.2.5/ChangeLog
--- glibc-2.2.5.old/ChangeLog	Sat Apr 27 22:28:07 2002
+++ glibc-2.2.5/ChangeLog	Tue Apr 23 10:45:10 2002
@@ -0,0 +1,12 @@
+2002-03-17  Roland McGrath  <roland@frob.com>
+
+        * sysdeps/mach/hurd/i386/sys/io.h: New file.
+        * sysdeps/mach/hurd/i386/ioperm.c: New file.
+        * sysdeps/mach/hurd/i386/Dist: Add them.
+        * sysdeps/mach/hurd/i386/Versions
+        (libc: GLIBC_2.2.6): New set, add ioperm.
+        * sysdeps/mach/configure.in: New check to set HAVE_I386_IO_PERM_MODIFY.
+        (mach_interface_list): Check for mach_i386.defs.
+        * config.h.in (HAVE_I386_IO_PERM_MODIFY): #undef it.
+        * sysdeps/mach/configure: Regenerated.
+
diff -urN glibc-2.2.5.old/config.h.in glibc-2.2.5/config.h.in
--- glibc-2.2.5.old/config.h.in	Sat Apr 27 22:28:01 2002
+++ glibc-2.2.5/config.h.in	Tue Apr 23 10:45:10 2002
@@ -146,6 +146,9 @@
 
 #endif
 
+/* Mach/i386 specific: define if the `i386_io_perm_*' RPCs are available.  */
+#undef HAVE_I386_IO_PERM_MODIFY
+
 /* Sparc64 specific: define if .dynamic section comes before .got for
    shared libs.  */
 #undef  SPARC64_DYNAMIC_BEFORE_GOT
diff -urN glibc-2.2.5.old/mach/Makefile glibc-2.2.5/mach/Makefile
--- glibc-2.2.5.old/mach/Makefile	Sat Apr 27 22:28:02 2002
+++ glibc-2.2.5/mach/Makefile	Sat Apr 27 10:05:01 2002
@@ -41,7 +41,7 @@
 user-interfaces := $(addprefix mach/,mach_interface mach_port mach_host	\
 				     memory_object_user			\
 				     memory_object_default		\
-				     exc mach4				\
+				     exc mach4 i386/mach_i386		\
 				     default_pager default_pager_helper	\
 	            )\
 		   $(addprefix device/,device device_request)
diff -urN glibc-2.2.5.old/sysdeps/mach/configure glibc-2.2.5/sysdeps/mach/configure
--- glibc-2.2.5.old/sysdeps/mach/configure	Wed Dec 31 19:00:00 1969
+++ glibc-2.2.5/sysdeps/mach/configure	Tue Apr 23 10:45:10 2002
@@ -0,0 +1,65 @@
+ 
+ac_safe=`echo "mach/i386/mach_i386.defs" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for mach/i386/mach_i386.defs""... $ac_c" 1>&6
+echo "configure:5: checking for mach/i386/mach_i386.defs" >&5
+if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 10 "configure"
+#include "confdefs.h"
+#include <mach/i386/mach_i386.defs>
+EOF
+ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
+{ (eval echo configure:15: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
+if test -z "$ac_err"; then
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=yes"
+else
+  echo "$ac_err" >&5
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_header_$ac_safe=no"
+fi
+rm -f conftest*
+fi
+if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  :
+else
+  echo "$ac_t""no" 1>&6
+fi
+
+
+echo $ac_n "checking for i386_io_perm_modify in mach_i386.defs""... $ac_c" 1>&6
+echo "configure:38: checking for i386_io_perm_modify in mach_i386.defs" >&5
+if eval "test \"`echo '$''{'libc_cv_mach_i386_ioports'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 43 "configure"
+#include "confdefs.h"
+#include <mach/i386/mach_i386.defs>
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "i386_io_perm_modify" >/dev/null 2>&1; then
+  rm -rf conftest*
+  libc_cv_mach_i386_ioports=yes
+else
+  rm -rf conftest*
+  libc_cv_mach_i386_ioports=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$ac_t""$libc_cv_mach_i386_ioports" 1>&6
+if test $libc_cv_mach_i386_ioports = yes; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_I386_IO_PERM_MODIFY 1
+EOF
+
+fi
+
diff -urN glibc-2.2.5.old/sysdeps/mach/configure.in glibc-2.2.5/sysdeps/mach/configure.in
--- glibc-2.2.5.old/sysdeps/mach/configure.in	Wed Dec 31 19:00:00 1969
+++ glibc-2.2.5/sysdeps/mach/configure.in	Tue Apr 23 10:45:10 2002
@@ -0,0 +1,14 @@
+sinclude(./aclocal.m4)dnl Autoconf lossage.
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+
+AC_CHECK_HEADER(mach/i386/mach_i386.defs)
+
+AC_CACHE_CHECK(for i386_io_perm_modify in mach_i386.defs,
+              libc_cv_mach_i386_ioports, [dnl
+AC_EGREP_HEADER(i386_io_perm_modify, mach/i386/mach_i386.defs,
+               libc_cv_mach_i386_ioports=yes,
+               libc_cv_mach_i386_ioports=no)])
+if test $libc_cv_mach_i386_ioports = yes; then
+  AC_DEFINE([HAVE_I386_IO_PERM_MODIFY])
+fi
+
diff -urN glibc-2.2.5.old/sysdeps/mach/hurd/i386/Dist glibc-2.2.5/sysdeps/mach/hurd/i386/Dist
--- glibc-2.2.5.old/sysdeps/mach/hurd/i386/Dist	Sat Jul  4 10:38:01 1998
+++ glibc-2.2.5/sysdeps/mach/hurd/i386/Dist	Tue Apr 23 10:45:10 2002
@@ -1 +1,3 @@
 static-start.S
+sys/io.h
+ioperm.c
diff -urN glibc-2.2.5.old/sysdeps/mach/hurd/i386/Makefile glibc-2.2.5/sysdeps/mach/hurd/i386/Makefile
--- glibc-2.2.5.old/sysdeps/mach/hurd/i386/Makefile	Wed Dec 31 19:00:00 1969
+++ glibc-2.2.5/sysdeps/mach/hurd/i386/Makefile	Wed Apr 24 13:46:02 2002
@@ -0,0 +1,5 @@
+ifeq ($(subdir),misc)
+sysdep_routines += ioperm
+sysdep_headers += sys/io.h
+endif
+
diff -urN glibc-2.2.5.old/sysdeps/mach/hurd/i386/Versions glibc-2.2.5/sysdeps/mach/hurd/i386/Versions
--- glibc-2.2.5.old/sysdeps/mach/hurd/i386/Versions	Thu Dec 20 10:54:54 2001
+++ glibc-2.2.5/sysdeps/mach/hurd/i386/Versions	Tue Apr 23 10:45:10 2002
@@ -4,4 +4,7 @@
     __register_frame; __register_frame_table; __deregister_frame;
     __frame_state_for; __register_frame_info_table;
   }
+  GLIBC_2.2.6 {
+    ioperm;
+  }
 }
diff -urN glibc-2.2.5.old/sysdeps/mach/hurd/i386/ioperm.c glibc-2.2.5/sysdeps/mach/hurd/i386/ioperm.c
--- glibc-2.2.5.old/sysdeps/mach/hurd/i386/ioperm.c	Wed Dec 31 19:00:00 1969
+++ glibc-2.2.5/sysdeps/mach/hurd/i386/ioperm.c	Wed Apr 24 14:01:11 2002
@@ -0,0 +1,53 @@
+/* Access to hardware i/o ports.  Hurd/x86 version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/io.h>
+#include <hurd.h>
+#include <mach/i386/mach_i386_types.h>
+#include <mach/i386/mach_i386.h>
+
+int
+ioperm (unsigned long int from, unsigned long int num, int turn_on)
+{
+#if ! HAVE_I386_IO_PERM_MODIFY
+  return __hurd_fail (ENOSYS);
+#else
+  error_t err;
+  device_t devmaster;
+
+  /* With the device master port we get a capability that represents
+     this range of io ports.  */
+  err = __get_privileged_ports (NULL, &devmaster);
+  if (! err)
+    {
+      io_perm_t perm;
+      err = __i386_io_perm_create (devmaster, from, from + num, &perm);
+      __mach_port_deallocate (__mach_task_self (), devmaster);
+      if (! err)
+	{
+	  /* Now we add or remove that set from our task's bitmap.  */
+	  err = __i386_io_perm_modify (__mach_task_self (), perm, turn_on);
+	  __mach_port_deallocate (__mach_task_self (), perm);
+	}
+    }
+
+  return err ? __hurd_fail (err) : 0;
+#endif
+}
+
diff -urN glibc-2.2.5.old/sysdeps/mach/hurd/i386/sys/io.h glibc-2.2.5/sysdeps/mach/hurd/i386/sys/io.h
--- glibc-2.2.5.old/sysdeps/mach/hurd/i386/sys/io.h	Wed Dec 31 19:00:00 1969
+++ glibc-2.2.5/sysdeps/mach/hurd/i386/sys/io.h	Tue Apr 23 10:45:10 2002
@@ -0,0 +1,179 @@
+/* Access to hardware i/o ports.  GNU/x86 version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef        _SYS_IO_H
+#define        _SYS_IO_H       1
+
+#include <features.h>
+   
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.  */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+                   int __turn_on) __THROW;
+   
+/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
+   access any I/O port is granted.  This call requires root
+   privileges. */
+extern int iopl (int __level) __THROW;
+   
+#if defined __GNUC__ && __GNUC__ >= 2
+   
+static __inline unsigned char
+inb (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned char
+inb_p (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+   
+static __inline unsigned short int
+inw (unsigned short int port)
+{
+  unsigned short _v;
+
+  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw_p (unsigned short int port)
+{
+  unsigned short int _v;
+
+  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl (unsigned short int port)
+{
+  unsigned int _v;
+
+  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl_p (unsigned short int port)
+{
+  unsigned int _v;
+  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+  
+static __inline void
+outb (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outb_p (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (value),
+                       "Nd" (port));
+}
+ 
+static __inline void
+outw (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1": :"a" (value), "Nd" (port));
+  
+}
+
+static __inline void
+outw_p (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (value),
+                       "Nd" (port));
+}
+ 
+static __inline void
+outl (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outl_p (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (value),
+                       "Nd" (port));
+}
+ 
+static __inline void
+insb (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (addr),
+                       "=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insw (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (addr),
+                       "=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insl (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (addr),
+                       "=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+ 
+static __inline void
+outsb (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (addr),
+                       "=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+ 
+static __inline void
+outsw (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (addr),
+                       "=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+ 
+static __inline void
+outsl (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (addr),
+                       "=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+ 
+#endif /* GNU C */
+
+__END_DECLS
+#endif /* _SYS_IO_H */
+
