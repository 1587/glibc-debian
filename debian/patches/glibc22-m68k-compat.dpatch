#! /bin/sh -e

# DP: Fixes some compatibility issues with m68k and lchown/chown

if [ $# -ne 2 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch -d "$2" -f --no-backup-if-mismatch -p1 < $0;;
    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p1 < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

diff -urN glibc-2.1.95.orig/sysdeps/unix/sysv/linux/m68k/chown.c glibc-2.1.95/sysdeps/unix/sysv/linux/m68k/chown.c
--- glibc-2.1.95.orig/sysdeps/unix/sysv/linux/m68k/chown.c	Fri Sep  1 05:58:10 2000
+++ glibc-2.1.95/sysdeps/unix/sysv/linux/m68k/chown.c	Sat Oct 14 14:58:38 2000
@@ -72,3 +72,8 @@
 #endif
 }
 weak_alias (__chown, chown)
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libc, GLIBC_2_1, GLIBC_2_2)
+compat_symbol (libc, __chown, chown, GLIBC_2_1);
+#endif
diff -urN glibc-2.1.95.orig/sysdeps/unix/sysv/linux/m68k.orig/lchown.c glibc-2.1.95/sysdeps/unix/sysv/linux/m68k/lchown.c
--- glibc-2.1.95.orig/sysdeps/unix/sysv/linux/m68k/lchown.c	Mon Jan 17 06:20:35 2000
+++ glibc-2.1.95/sysdeps/unix/sysv/linux/m68k/lchown.c	Mon Oct 16 18:59:45 2000
@@ -1 +1,126 @@
-#include <sysdeps/unix/sysv/linux/i386/lchown.c>
+/* Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include <linux/posix_types.h>
+#include "kernel-features.h"
+
+extern int __syscall_chown (const char *__unbounded __file,
+                            __kernel_uid_t __owner, __kernel_gid_t __group);
+
+#if defined __NR_lchown || __ASSUME_LCHOWN_SYSCALL > 0
+extern int __syscall_lchown (const char *__unbounded __file,
+			     __kernel_uid_t __owner, __kernel_gid_t __group);
+
+# ifdef __NR_lchown32
+extern int __syscall_lchown32 (const char *__unbounded __file,
+			       __kernel_uid32_t __owner, __kernel_gid32_t __group);
+#  if __ASSUME_32BITUIDS == 0
+/* This variable is shared with all files that need to check for 32bit
+   uids.  */
+extern int __libc_missing_32bit_uids;
+#  endif
+# endif /* __NR_lchown32 */
+#endif /* __NR_lchown || __ASSUME_LCHOWN_SYSCALL > 0 */
+
+int
+__lchown (const char *file, uid_t owner, gid_t group)
+{
+#if defined __NR_lchown || __ASSUME_LCHOWN_SYSCALL > 0
+# if __ASSUME_LCHOWN_SYSCALL == 0
+  static int __libc_old_chown;
+  int result;
+
+  if(!__libc_old_chown)
+    {
+      int saved_errno = errno;
+#  ifdef __NR_lchown32
+      if (__libc_missing_32bit_uids <= 0)
+	{
+	  int saved_errno = errno;
+
+	  result = INLINE_SYSCALL (lchown32, 3, CHECK_STRING (file), owner, group);
+	  if (result == 0 || errno != ENOSYS)
+	    return result;
+
+	  __set_errno (saved_errno);
+	  __libc_missing_32bit_uids = 1;
+	}
+#  endif /* __NR_lchown32 */
+
+      if (((owner + 1) > (uid_t) ((__kernel_uid_t) -1U))
+          || ((group + 1) > (gid_t) ((__kernel_gid_t) -1U)))
+	{
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+
+      result = INLINE_SYSCALL (lchown, 3, CHECK_STRING (file), owner, group);
+      if (result == 0 || errno != ENOSYS)
+	return result;
+
+      __set_errno (saved_errno);
+      __libc_old_chown = 1;
+    }
+
+  return INLINE_SYSCALL (chown, 3, CHECK_STRING (file), owner, group);
+
+# elif __ASSUME_32BITUIDS
+  return INLINE_SYSCALL (lchown32, 3, CHECK_STRING (file), owner, group);
+# else
+#  ifdef __NR_lchown32
+  if (__libc_missing_32bit_uids <= 0)
+    {
+      int result;
+      int saved_errno = errno;
+
+      result = INLINE_SYSCALL (lchown32, 3, CHECK_STRING (file), owner, group);
+      if (result == 0 || errno != ENOSYS)
+	return result;
+
+      __set_errno (saved_errno);
+      __libc_missing_32bit_uids = 1;
+    }
+#  endif /* __NR_lchown32 */
+
+  if (((owner + 1) > (uid_t) ((__kernel_uid_t) -1U))
+      || ((group + 1) > (gid_t) ((__kernel_gid_t) -1U)))
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  return INLINE_SYSCALL (lchown, 3, CHECK_STRING (file), owner, group);
+# endif
+#else
+  return INLINE_SYSCALL (chown, 3, CHECK_STRING (file), owner, group);
+#endif
+}
+
+weak_alias (__lchown, lchown)
+
+#include <shlib-compat.h>
+#if SHLIB_COMPAT (libc, GLIBC_2_1, GLIBC_2_2)
+compat_symbol (libc, __lchown, lchown, GLIBC_2_1);
+#endif
