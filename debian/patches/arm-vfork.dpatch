#! /bin/sh -e

# All lines beginning with `# DP:' are a description of the patch.
# DP: Description: fix problem with vfork and libpthread on arm
# DP: Related bugs: 
# DP: Author: Phil Blundell
# DP: Upstream status: In CVS
# DP: Status Details: 
# DP: Date: 

if [ $# -ne 2 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch) patch -d "$2" -f --no-backup-if-mismatch -p0 < $0;;
    -unpatch) patch -d "$2" -f --no-backup-if-mismatch -R -p0 < $0;;
    *)
	echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
	exit 1
esac
exit 0

# append the patch here and adjust the -p? flag in the patch calls.
2003-09-17  Philip Blundell  <philb@gnu.org>

	* sysdeps/unix/sysv/linux/arm/vfork.S: Branch to fork if
	libpthread is loaded.  Elide backwards compatibility code when not
	required.

Index: linuxthreads/sysdeps/unix/sysv/linux/arm/vfork.S
===================================================================
RCS file: /cvs/glibc/libc/linuxthreads/sysdeps/unix/sysv/linux/arm/vfork.S,v
retrieving revision 1.2
diff -u -p -r1.2 vfork.S
--- linuxthreads/sysdeps/unix/sysv/linux/arm/vfork.S	15 Jan 2003 01:06:06 -0000	1.2
+++ linuxthreads/sysdeps/unix/sysv/linux/arm/vfork.S	17 Sep 2003 16:34:32 -0000
@@ -20,36 +20,59 @@
 #include <sysdep-cancel.h>
 #define _ERRNO_H	1
 #include <bits/errno.h>
+#include <kernel-features.h>
 
-/* Clone the calling process, but without copying the whole address
-pace.
+/* Clone the calling process, but without copying the whole address space.
    The calling process is suspended until the new process exits or is
-   replaced by a call to `execve'.  Return -1 for errors, 0 to the new
-rocess,
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
    and the process ID of the new process to the old process.  */
 
 	PSEUDO_PROLOGUE
 
 ENTRY (__vfork)
 
-	SINGLE_THREAD_P
-	bne	HIDDEN_JUMPTARGET (__fork)
 #ifdef __NR_vfork
+
+#ifdef SHARED
+	ldr	ip, 1f
+	ldr	r0, 2f
+3:	add	ip, pc, ip
+	ldr	r0, [ip, r0]
+#else
+	ldr	r0, 1f
+#endif
+	movs	r0, r0
+	bne	HIDDEN_JUMPTARGET (__fork)
+		
 	swi	__NR_vfork
 	cmn	a1, #4096
 	RETINSTR(movcc, pc, lr)
 
+#ifndef __ASSUME_VFORK_SYSCALL
 	/* Check if vfork syscall is known at all.  */
-	ldr	a2, =-ENOSYS
-	teq	a1, a2
+	cmn	a1, #ENOSYS
 	bne	PLTJMP(C_SYMBOL_NAME(__syscall_error))
 #endif
 
+#endif
+
+#ifndef __ASSUME_VFORK_SYSCALL
 	/* If we don't have vfork, fork is close enough.  */
 	swi	__NR_fork
 	cmn	a1, #4096
 	RETINSTR(movcc, pc, lr)
+#elif !defined __NR_vfork
+# error "__NR_vfork not available and __ASSUME_VFORK_SYSCALL defined"
+#endif
     	b	PLTJMP(C_SYMBOL_NAME(__syscall_error))
+
+#ifdef SHARED
+1:	.word	_GLOBAL_OFFSET_TABLE_ - 3b - 8
+2:	.word	__libc_pthread_functions(GOTOFF)
+#else
+	.weak	pthread_create
+1:	.word	pthread_create
+#endif
 
 PSEUDO_END (__vfork)
 libc_hidden_def (__vfork)
