diff -Nurd glibc-2.4/ports/ChangeLog.hppa glibc-2.4/ports/ChangeLog.hppa
--- glibc-2.4/ports/ChangeLog.hppa	2006-02-28 23:20:13.000000000 +0100
+++ glibc-2.4/ports/ChangeLog.hppa	2006-08-06 09:40:19.000000000 +0200
@@ -1,3 +1,187 @@
+2006-07-24  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/nptl/bits/pthreadtypes.h: 
+	__SIZEOF_PTHREAD_COND_T is 64 bytes. Remove __PAD_ATOMIC_LOCK_T.
+
+2006-07-18  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/nptl/pthread_spin_lock.c (pthread_spin_lock): Swap
+	newval and oldval.
+	* sysdeps/hppa/nptl/pthread_spin_trylock.c (pthread_spin_trylock):
+	Likewise.
+
+2006-07-16  Jeff Bailey  <jbailey@ubuntu.com>
+
+	* sysdeps/hppa/tst-audit.h: New file.
+
+2006-07-16  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/tls-macros.h: Cleanup formatting.
+
+2006-07-15  Jeff Bailey  <jbailey@ubuntu.com>
+
+	* sysdeps/hppa/nptl/tls.h (TLS_INIT_TP): Return NULL.
+
+2006-07-13  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/xstat.c: New file.
+	* sysdeps/unix/sysv/linux/hppa/lxstat.c: Likewise.
+	* sysdeps/unix/sysv/linux/hppa/fxstat.c: Likewise. 
+	* sysdeps/unix/sysv/linux/hppa/fxstatat.c: Likewise.
+
+2006-07-13  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/nptl/Makefile: New file
+	* sysdeps/hppa/nptl/jmpbuf-unwind.h: Likewise
+	* sysdeps/hppa/nptl/pthread_spin_lock.c: Likewise
+	* sysdeps/hppa/nptl/pthread_spin_trylock.c: Likewise
+	* sysdeps/hppa/nptl/pthread_spin_unlock.c: Likewise
+	* sysdeps/hppa/nptl/pthreaddef.h: Likewise
+	* sysdeps/hppa/nptl/tcb-offsets.sym: Likewise
+	* sysdeps/hppa/nptl/tls.h: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/bits: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/createthread.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/fork.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/internaltypes.h: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/libc-lowlevellock.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/lowlevellock.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/lowlevellock.h: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/pt-initfini.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/pt-vfork.S: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/pthread_once.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/sysdep-cancel.h: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/unwind-forcedunwind.c: Likewise
+	* sysdeps/unix/sysv/linux/hppa/nptl/unwind-resume.c: Likewise
+
+2006-06-08  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/Versions: new errlist compat entry 
+	for up to 256 errnos
+
+2006-06-08  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/hppa1.1/Implies: Remove ieee754/ldbl-128. 
+	* sysdeps/unix/sysv/linux/hppa/kernel-features.h
+	[__LINUX_KERNEL_VERSION >= 0x020609]: Define __ASSUME_LWS_CAS.
+	* sysdeps/unix/sysv/linux/hppa/bits/atomic.h: New file.
+
+2006-06-08  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/bits/fcntl.h: Reformat
+	(SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT):
+	Define.
+
+2006-05-24  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/clone.S: .LerrorRest
+	is a label.
+
+2006-05-24  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/ldsodefs.h: New file.
+	* sysdeps/unix/sysv/linux/hppa/bits/mman.h:
+	Only define MADV_* macros when __USE_BSD is present.
+	(MADV_REMOVE, MADV_DONTFORK, MADV_DOFORK): Define.
+
+2006-05-15  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/clone.S: Accept extra arguments
+	required for NPTL.
+	* sysdeps/unix/sysv/linux/hppa/sysdep.c: Use var args for 6 arg
+	syscall.
+	* sysdeps/unix/sysv/linux/hppa/sysdep.h: Move DOARGS and UNDOARGS
+	into PSEUDO_*'s.
+	(ENTRY_LEAF): Define.
+	(PSEUDO_NOERRNO, PSEUDO_ERRVAL): Use ENTRY_LEAF.
+	(DO_CALL): Create frame.
+
+2006-05-15  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/dl-machine.h: Include tls.h
+	(elf_machine_fixup_plt): Returns fdesc.
+	(elf_machine_profile_fixup_plt): Remove.
+	(elf_machine_plt_value): Returns fdesc.
+	(elf_machine_runtime_setup): Check that dl_profile != NULL.
+	(ARCH_LA_PLTENT, ARCH_LA_PLTEXIT): Define.
+	(RTLD_START): Use iitlbp with sr0.
+	(elf_machine_type_class): Include TLS relocs.
+	(reassemble_21, reassemble_14): Define.
+	(elf_machine_rela): Add DIR21L, DIR14R, PLABEL21L, PLABEL14R,
+	TLS_DTPMOD32, TLS_TPREL32, TLS_DTPOFF32 support.
+	(TRAMPOLINE_TEMPLATE): Move to ...
+	* sysdeps/hppa/dl-trampoline.S: ... here.
+	* sysdeps/hppa/abort-instr.h: Use iitlbp with sr0.
+	* sysdeps/hppa/dl-lookupcfg.h: Inlcude dl-fptr.h.
+	(DL_FIXUP_VALUE_TYPE, DL_FIXUP_MAKE_VALUE, DL_FIXUP_VALUE_CODE_ADDR,
+	DL_FIXUP_VALUE_ADD, DL_FIXUP_ADDR_VALUE): Define.
+	* sysdeps/hppa/sysdep.h: Use "!" as a separator. Cleanup comments.
+	* sysdeps/hppa/bits/link.h (La_hppa_regs, La_hppa_retval): Define.
+	Define prototypes for la_hppa_gnu_pltenter and la_hppa_gnu_pltexit.
+
+2006-04-27  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/bits/fcntl.h: Include uio.h, and
+	define vmsplice.
+
+2006-04-21  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/dl-tls.h: New file
+	* sysdeps/hppa/libc-tls.c: Likewise.
+	* sysdeps/hppa/tls-macros.h: Likewise.
+	* sysdeps/hppa/elf/configure: Likewise.
+	* sysdeps/hppa/elf/configure.in: Likewise.
+
+2006-04-20  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/fpu/fclrexcpt.c (feclearexcept): Use union to
+	align parameters. Specify memory clobbers.
+	* sysdeps/hppa/fpu/fedisblxcpt.c (fedisableexcept): Likewise.
+	* sysdeps/hppa/fpu/feenablxcpt.c (feenableexcept): Likewise.
+	* sysdeps/hppa/fpu/fegetenv.c (fegetenv): Do not save exception
+	register. Use memcpy to align buffer.
+	* sysdeps/hppa/fpu/fegetexcept.c (fegetexcept): Store and reload
+	fr0. Use union to align parameters.
+	* sysdeps/hppa/fpu/fegetround.c (fegetround): Likewise.
+	* sysdeps/hppa/fpu/feholdexcpt.c (feholdexcept): Do not save
+	exception registers. Define libm_hidden_def.
+	* sysdeps/hppa/fpu/fesetenv.c (fesetenv): Do not save exception
+	registers.
+	* sysdeps/hppa/fpu/fesetround.c (fesetround): Use union to
+	align parameters, speficy memory clobbers. Define libm_hidde_def
+	* sysdeps/hppa/fpu/feupdateenv.c (feupdateenv): Use union to align
+	parameters. Use memcpy to align buffer.
+	* sysdeps/hppa/fpu/fgetexcptflg.c (fegetexceptflag): Likewise.
+	* sysdeps/hppa/fpu/fsetexcptflg.c (fesetexceptflag): Likewise.
+	* sysdeps/hppa/fpu/ftestexcept.c (fetestexcept): Likewise.
+	* sysdeps/hppa/fpu/libm-test-ulps: Update.
+	* sysdeps/hppa/fpu/bits/fenv.h: Add ABI comments.
+
+2006-04-19  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/bits/mman.h [__USE_GNU]: 
+	Define MMAP_FIXED.
+	* sysdeps/unix/sysv/linux/hppa/bits/fcntl.h [__USE_GNU]: 
+	Define SYNC_FILE_RANGE_WAIT_BEFORE, SYNC_FILE_RANGE_WRITE,
+	SYNC_FILE_RANGE_WAIT_AFTER, sync_file_range, splice, tee.
+
+2006-04-19  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/unix/sysv/linux/hppa/kernel-features.h: New file.
+
+2006-04-19  Carlos O'Donell  <carlos@systemhalted.org>
+
+	* sysdeps/hppa/linuxthreads/pspinlock.c: New file.
+	* sysdeps/hppa/linuxthreads/pt-machine.h: Likewise.
+	* sysdeps/hppa/linuxthreads/tls.h: Likewise.
+	* sysdeps/unix/sysv/linux/hppa/linuxthreads/aio_cancel.c: Likewise.
+	* sysdeps/unix/sysv/linux/hppa/linuxthreads/malloc-machine.h:
+	Likewise.
+	* sysdeps/unix/sysv/linux/hppa/linuxthreads/pt-initfini.c: Likewise.
+	* sysdeps/unix/sysv/linux/hppa/linuxthreads/sysdep-cancel.h: Likewise.
+	* sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/initspin.h: Likewise.
+	* sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/pthreadtypes.h:
+	Likewise.
+
 2006-02-28  Roland McGrath  <roland@redhat.com>
 
 	* sysdeps/hppa/shlib-versions: New file.
diff -Nurd glibc-2.4/ports/sysdeps/hppa/abort-instr.h glibc-2.4/ports/sysdeps/hppa/abort-instr.h
--- glibc-2.4/ports/sysdeps/hppa/abort-instr.h	2002-09-23 05:30:34.000000000 +0200
+++ glibc-2.4/ports/sysdeps/hppa/abort-instr.h	2006-05-15 01:54:47.000000000 +0200
@@ -3,4 +3,4 @@
    We go with iitlbp because it has a history of being used to crash
    programs.  */
 
-#define ABORT_INSTRUCTION asm ("iitlbp %r0,(%r0)")
+#define ABORT_INSTRUCTION asm ("iitlbp %r0,(%sr0, %r0)")
diff -Nurd glibc-2.4/ports/sysdeps/hppa/bits/link.h glibc-2.4/ports/sysdeps/hppa/bits/link.h
--- glibc-2.4/ports/sysdeps/hppa/bits/link.h	2005-01-06 23:40:18.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/bits/link.h	2006-05-15 01:54:47.000000000 +0200
@@ -0,0 +1,57 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+/* Registers for entry into PLT on hppa.  */
+typedef struct La_hppa_regs
+{
+  uint32_t lr_reg[4];
+  double lr_fpreg[4];
+  uint32_t lr_sp;
+  uint32_t lr_ra;
+} La_hppa_regs;
+
+/* Return values for calls from PLT on hppa.  */
+typedef struct La_hppa_retval
+{
+  uint32_t lrv_r28;
+  uint32_t lrv_r29;
+  double lr_fr4;
+} La_hppa_retval;
+
+
+__BEGIN_DECLS
+
+extern Elf32_Addr la_hppa_gnu_pltenter (Elf32_Sym *__sym, unsigned int __ndx,
+				       uintptr_t *__refcook,
+				       uintptr_t *__defcook,
+				       La_hppa_regs *__regs,
+				       unsigned int *__flags,
+				       const char *__symname,
+				       long int *__framesizep);
+extern unsigned int la_hppa_gnu_pltexit (Elf32_Sym *__sym, unsigned int __ndx,
+					uintptr_t *__refcook,
+					uintptr_t *__defcook,
+					const La_hppa_regs *__inregs,
+					La_hppa_retval *__outregs,
+					const char *symname);
+
+__END_DECLS
diff -Nurd glibc-2.4/ports/sysdeps/hppa/dl-lookupcfg.h glibc-2.4/ports/sysdeps/hppa/dl-lookupcfg.h
--- glibc-2.4/ports/sysdeps/hppa/dl-lookupcfg.h	2005-01-06 23:40:18.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/dl-lookupcfg.h	2006-05-15 01:54:47.000000000 +0200
@@ -20,6 +20,8 @@
 #define ELF_FUNCTION_PTR_IS_SPECIAL
 #define DL_UNMAP_IS_SPECIAL
 
+#include <dl-fptr.h>
+
 /* Forward declaration.  */
 struct link_map;
 
@@ -63,3 +65,16 @@
   ((Elf32_Addr)(addr) & 2 ? (addr) : DL_AUTO_FUNCTION_ADDRESS (map, addr))
 #define DL_DT_FINI_ADDRESS(map, addr) \
   ((Elf32_Addr)(addr) & 2 ? (addr) : DL_AUTO_FUNCTION_ADDRESS (map, addr))
+
+/* The type of the return value of fixup/profile_fixup */
+#define DL_FIXUP_VALUE_TYPE struct fdesc
+
+/* Construct a fixup value from the address and linkmap */
+#define DL_FIXUP_MAKE_VALUE(map, addr) \
+   ((struct fdesc) { (addr), (map)->l_info[DT_PLTGOT]->d_un.d_ptr })
+
+/* Extract the code address from a fixup value */
+#define DL_FIXUP_VALUE_CODE_ADDR(value) ((value).ip)
+#define DL_FIXUP_VALUE_ADDR(value) ((uintptr_t) &(value))
+#define DL_FIXUP_ADDR_VALUE(addr) (*(struct fdesc *) (addr))
+
diff -Nurd glibc-2.4/ports/sysdeps/hppa/dl-machine.h glibc-2.4/ports/sysdeps/hppa/dl-machine.h
--- glibc-2.4/ports/sysdeps/hppa/dl-machine.h	2004-11-19 01:01:25.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/dl-machine.h	2006-05-15 01:54:46.000000000 +0200
@@ -31,6 +31,7 @@
 #include <errno.h>
 #include <dl-fptr.h>
 #include <abort-instr.h>
+#include <tls.h>
 
 # define VALID_ELF_OSABI(osabi)		((osabi == ELFOSABI_SYSV) || (osabi == ELFOSABI_LINUX))
 # define VALID_ELF_ABIVERSION(ver)	(ver == 0)
@@ -116,43 +117,28 @@
   return dynamic - elf_machine_dynamic ();
 }
 
-/* Fixup a PLT entry to bounce directly to the function at VALUE.  
-   Optimized non-profile version. */
-static inline Elf32_Addr
+/* Fixup a PLT entry to bounce directly to the function at VALUE. */ 
+static inline struct fdesc __attribute__ ((always_inline)) 
 elf_machine_fixup_plt (struct link_map *map, lookup_t t,
 		       const Elf32_Rela *reloc,
-		       Elf32_Addr *reloc_addr, Elf32_Addr value)
+		       Elf32_Addr *reloc_addr, struct fdesc value)
 {
   /* map is the link_map for the caller, t is the link_map for the object
      being called */
-  reloc_addr[1] = D_PTR (t, l_info[DT_PLTGOT]);
-  reloc_addr[0] = value;
-  /* Return the PLT slot rather than the function value so that the
-     trampoline can load the new LTP. */
-  return (Elf32_Addr) reloc_addr;
-}
-
-/* Fixup a PLT entry to bounce directly to the function at VALUE.  */
-#define ELF_MACHINE_PROFILE_FIXUP_PLT elf_machine_profile_fixup_plt
-static inline Elf32_Addr
-elf_machine_profile_fixup_plt (struct link_map *map, lookup_t t,
-		       const Elf32_Rela *reloc,
-		       Elf32_Addr *reloc_addr, Elf32_Addr value)
-{
-  if(__builtin_expect (t == NULL, 1)) 
-    return (Elf32_Addr) reloc_addr;
-  /* Return the PLT slot rather than the function value so that the
-     trampoline can load the new LTP. */
-  return (Elf32_Addr) elf_machine_fixup_plt(map, t, reloc, reloc_addr, value);
+  reloc_addr[1] = value.gp;
+  /* Need to ensure that the gp is visible before the code
+     entry point is updated */
+  ((volatile Elf32_Addr *) reloc_addr)[0] = value.ip;
+  return value;
 }
 
 /* Return the final value of a plt relocation.  */
-static inline Elf32_Addr
+static inline struct fdesc 
 elf_machine_plt_value (struct link_map *map, const Elf32_Rela *reloc,
-		       Elf32_Addr value)
+		       struct fdesc value)
 {
-  /* We are rela only */
-  return value + reloc->r_addend;
+  /* We are rela only, return a function descriptor as a plt entry. */
+  return (struct fdesc) { value.ip + reloc->r_addend, value.gp };
 }
 
 /* Set up the loaded object described by L so its unrelocated PLT
@@ -181,7 +167,7 @@
   
   extern void _dl_runtime_resolve (void);
   extern void _dl_runtime_profile (void);
-  
+ 
   /* Linking lazily */
   if (lazy)
     {
@@ -215,9 +201,10 @@
 	    {
               /* Found the GOT! */       	
               register Elf32_Addr ltp __asm__ ("%r19");
-              /* Identify this shared object. */
+              
+              /* Identify this shared object. Second entry in the got. */
               got[1] = (Elf32_Addr) l;
-
+              
               /* This function will be called to perform the relocation. */
               if (__builtin_expect (!profile, 1))
                 {
@@ -236,7 +223,8 @@
                 }
               else
 	        {
-	          if (_dl_name_match_p (GLRO(dl_profile), l))
+	          if (GLRO(dl_profile) != NULL
+		      && _dl_name_match_p (GLRO(dl_profile), l))
 	            {
 		      /* This is the object we are looking for.  Say that
 		         we really want profiling and the timers are
@@ -316,6 +304,11 @@
   return lazy;
 }
 
+
+/* Names of the architecture-specific auditing callback functions.  */
+#define ARCH_LA_PLTENTER hppa_gnu_pltenter
+#define ARCH_LA_PLTEXIT hppa_gnu_pltexit
+
 /* Initial entry point code for the dynamic linker.
    The C function `_dl_start' is the real entry point;
    its return value is the user program's entry point.  */
@@ -367,7 +360,7 @@
 "	ldw,ma	8(%r26),%r19\n"						\
 									\
 	/* Uh oh!  We didn't find one.  Abort. */			\
-"	iitlbp	%r0,(%r0)\n"						\
+"	iitlbp	%r0,(%sr0,%r0)\n"					\
 									\
 "2:	ldw	-4(%r26),%r19\n"	/* Found it, load value. */	\
 "	add	%r19,%r20,%r19\n"	/* And add the load offset. */	\
@@ -471,85 +464,28 @@
 "	ldw	4(%r3),%r19\n"	/* load the object's gp */		\
 "	bv	%r0(%r2)\n"						\
 "	depi	2,31,2,%r23\n"	/* delay slot */			\
-	);
-
-
-/* This code gets called via the .plt stub, and is used in
-   dl-runtime.c to call the `fixup' function and then redirect to the
-   address it returns.
-   
-   WARNING: This template is also used by gcc's __cffc, and expects
-   that the "bl" for fixup() exist at a particular offset.
-   Do not change this template without changing gcc, while the prefix
-   "bl" should fix everything so gcc finds the right spot, it will
-   slow down __cffc when it attempts to call fixup to resolve function
-   descriptor references. Please refer to gcc/gcc/config/pa/fptr.c
-   
-   Enter with r19 = reloc offset, r20 = got-8, r21 = fixup ltp.  */
-#define TRAMPOLINE_TEMPLATE(tramp_name, fixup_name) 			\
-  extern void tramp_name (void);		    			\
-  asm (									\
- "	.text\n"							\
- 	/* FAKE bl to provide gcc's __cffc with fixup's address */	\
- "	bl	" #fixup_name ",%r2\n" /* Runtime address of fixup */	\
- "	.globl " #tramp_name "\n"					\
- "	.type " #tramp_name ",@function\n"				\
-  #tramp_name ":\n"							\
- "	.proc\n"							\
- "	.callinfo frame=64,calls,save_rp\n"				\
- "	.entry\n"							\
- 	/* Save return pointer */					\
- "	stw	%r2,-20(%sp)\n"						\
- 	/* Save argument registers in the call stack frame. */		\
- "	stw	%r26,-36(%sp)\n"					\
- "	stw	%r25,-40(%sp)\n"					\
- "	stw	%r24,-44(%sp)\n"					\
- "	stw	%r23,-48(%sp)\n"					\
- 	/* Build a call frame, and save structure pointer. */		\
- "	stwm	%r28,64(%sp)\n"						\
- 									\
- 	/* Set up args to fixup func.  */				\
- "	ldw	8+4(%r20),%r26\n" /* (1) got[1] == struct link_map */	\
- "	copy	%r19,%r25\n"	  /* (2) reloc offset  */		\
- "	copy    %r2,%r24\n"	  /* (3) profile_fixup needs rp */	\
- 									\
- 	/* Call the real address resolver. */				\
- "	bl	" #fixup_name ",%r2\n"					\
- "	copy	%r21,%r19\n"	  /* set fixup func ltp (DELAY SLOT)*/	\
- 									\
- "	ldw	0(%r28),%r22\n"	  /* load up the returned func ptr */	\
- "	ldw	4(%r28),%r19\n"						\
- "	ldwm	-64(%sp),%r28\n"					\
- 	/* Arguments. */						\
- "	ldw	-36(%sp),%r26\n"					\
- "	ldw	-40(%sp),%r25\n"					\
- "	ldw	-44(%sp),%r24\n"					\
- "	ldw	-48(%sp),%r23\n"					\
- 	/* Call the real function. */					\
- "	bv	%r0(%r22)\n"						\
- 	/* Return pointer. */						\
- "	ldw	-20(%sp),%r2\n"						\
- "	.exit\n"							\
- "	.procend\n");
-  
-#ifndef PROF
-#define ELF_MACHINE_RUNTIME_TRAMPOLINE			\
-  TRAMPOLINE_TEMPLATE (_dl_runtime_resolve, fixup);	\
-  TRAMPOLINE_TEMPLATE (_dl_runtime_profile, profile_fixup);
-#else
-#define ELF_MACHINE_RUNTIME_TRAMPOLINE			\
-  TRAMPOLINE_TEMPLATE (_dl_runtime_resolve, fixup);	\
-  strong_alias (_dl_runtime_resolve, _dl_runtime_profile);
-#endif
+);
 
-/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry, so
-   PLT entries should not be allowed to define the value.
+/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry or 
+   a TLS variable, so references should not be allowed to define the value.
    ELF_RTYPE_CLASS_NOCOPY iff TYPE should not be allowed to resolve to one
    of the main executable's symbols, as for a COPY reloc.  */
-#define elf_machine_type_class(type) \
-  ((((type) == R_PARISC_IPLT || (type) == R_PARISC_EPLT)	\
-    * ELF_RTYPE_CLASS_PLT)					\
+#if defined USE_TLS && (!defined RTLD_BOOTSTRAP || USE___THREAD)
+# define elf_machine_type_class(type)				\
+  ((((type) == R_PARISC_IPLT	 				\
+  || (type) == R_PARISC_EPLT					\
+  || (type) == R_PARISC_TLS_DTPMOD32				\
+  || (type) == R_PARISC_TLS_DTPOFF32				\
+  || (type) == R_PARISC_TLS_TPREL32)				\
+  * ELF_RTYPE_CLASS_PLT)					\
+  | (((type) == R_PARISC_COPY) * ELF_RTYPE_CLASS_COPY))
+#else
+#define elf_machine_type_class(type) 				\
+ ((((type) == R_PARISC_IPLT					\
+   || (type) == R_PARISC_EPLT)					\
+   * ELF_RTYPE_CLASS_PLT)					\
    | (((type) == R_PARISC_COPY) * ELF_RTYPE_CLASS_COPY))
+#endif
 
 /* Used by the runtime in fixup to figure out if reloc is *really* PLT */
 #define ELF_MACHINE_JMP_SLOT R_PARISC_IPLT
@@ -579,9 +515,22 @@
 /* These are only actually used where RESOLVE_MAP is defined, anyway. */
 #ifdef RESOLVE_MAP
 
+#define reassemble_21(as21) \
+  (  (((as21) & 0x100000) >> 20) \
+   | (((as21) & 0x0ffe00) >> 8) \
+   | (((as21) & 0x000180) << 7) \
+   | (((as21) & 0x00007c) << 14) \
+   | (((as21) & 0x000003) << 12))
+
+#define reassemble_14(as14) \
+  (  (((as14) & 0x1fff) << 1) \
+   | (((as14) & 0x2000) >> 13))
+
 auto void __attribute__((always_inline))
-elf_machine_rela (struct link_map *map, const Elf32_Rela *reloc,
-		  const Elf32_Sym *sym, const struct r_found_version *version,
+elf_machine_rela (struct link_map *map, 
+    		  const Elf32_Rela *reloc,
+		  const Elf32_Sym *sym, 
+		  const struct r_found_version *version,
 		  void *const reloc_addr_arg)
 {
   Elf32_Addr *const reloc_addr = reloc_addr_arg;
@@ -590,7 +539,7 @@
   struct link_map *sym_map;
   Elf32_Addr value;
 
-# if !defined RTLD_BOOTSTRAP && !defined SHARED
+# if !defined RTLD_BOOTSTRAP && !defined HAVE_Z_COMBRELOC && !defined SHARED
   /* This is defined in rtld.c, but nowhere in the static libc.a; make the
      reference weak so static programs can still link.  This declaration
      cannot be done when compiling rtld.c (i.e.  #ifdef RTLD_BOOTSTRAP)
@@ -612,6 +561,7 @@
 # else
   sym_map = RESOLVE_MAP (&sym, version, r_type);
 # endif
+  
   if (sym_map)
     {
       value = sym ? sym_map->l_addr + sym->st_value : 0;
@@ -635,6 +585,27 @@
 	}
       break;
 
+    case R_PARISC_DIR21L:
+      {
+	unsigned int insn = *(unsigned int *)reloc_addr;
+        value = sym_map->l_addr + sym->st_value 
+		+ ((reloc->r_addend + 0x1000) & -0x2000);
+	value = value >> 11;
+	insn = (insn &~ 0x1fffff) | reassemble_21 (value);
+	*(unsigned int *)reloc_addr = insn;
+      }
+      return;
+
+    case R_PARISC_DIR14R:
+      {
+	unsigned int insn = *(unsigned int *)reloc_addr;
+	value = ((sym_map->l_addr + sym->st_value) & 0x7ff) 
+		+ (((reloc->r_addend & 0x1fff) ^ 0x1000) - 0x1000);
+	insn = (insn &~ 0x3fff) | reassemble_14 (value);
+	*(unsigned int *)reloc_addr = insn;
+      }
+      return;
+
     case R_PARISC_PLABEL32:
       /* Easy rule: If there is a symbol and it is global, then we
          need to make a dynamic function descriptor.  Otherwise we
@@ -653,15 +624,42 @@
       value = (Elf32_Addr)((unsigned int)_dl_make_fptr (sym_map, sym, value) | 2);
       break;
 
+    case R_PARISC_PLABEL21L:
+    case R_PARISC_PLABEL14R:
+      {
+	unsigned int insn = *(unsigned int *)reloc_addr;
+
+        if (__builtin_expect (sym == NULL, 0))
+          break;
+
+        value = (Elf32_Addr)((unsigned int)_dl_make_fptr (sym_map, sym, value) | 2);
+
+        if (r_type == R_PARISC_PLABEL21L)
+	  {
+	    value >>= 11;
+	    insn = (insn &~ 0x1fffff) | reassemble_21 (value);
+	  }
+        else
+	  {
+	    value &= 0x7ff;
+	    insn = (insn &~ 0x3fff) | reassemble_14 (value);
+	  }
+
+	*(unsigned int *)reloc_addr = insn;
+      }
+      return;
+
     case R_PARISC_IPLT:
       if (__builtin_expect (sym_map != NULL, 1))
         {
-	  elf_machine_fixup_plt (NULL, sym_map, reloc, reloc_addr, value);
+	  elf_machine_fixup_plt (NULL, sym_map, reloc, reloc_addr, 
+	      			 DL_FIXUP_MAKE_VALUE(sym_map, value));
         } 
       else 
         {
 	  /* If we get here, it's a (weak) undefined sym.  */
-	  elf_machine_fixup_plt (NULL, map, reloc, reloc_addr, value);
+	  elf_machine_fixup_plt (NULL, map, reloc, reloc_addr, 
+	      			 DL_FIXUP_MAKE_VALUE(map, value));
         }
       return;
 
@@ -685,6 +683,28 @@
       memcpy (reloc_addr_arg, (void *) value,
 	      MIN (sym->st_size, refsym->st_size));
       return;
+
+#if defined USE_TLS && (!defined RTLD_BOOTSTRAP)
+    case R_PARISC_TLS_DTPMOD32:
+      value = sym_map->l_tls_modid;
+      break;
+
+    case R_PARISC_TLS_DTPOFF32:
+      /* During relocation all TLS symbols are defined and used.
+         Therefore the offset is already correct.  */
+      if (sym != NULL)
+        *reloc_addr = sym->st_value;
+      return;
+
+    case R_PARISC_TLS_TPREL32:
+      /* The offset is negative, forward from the thread pointer */
+      if (sym != NULL)
+        {
+          CHECK_STATIC_TLS (map, sym_map);
+	  value = sym_map->l_tls_offset + sym->st_value + reloc->r_addend;
+	}
+      break;
+#endif	/* use TLS */
       
     case R_PARISC_NONE:	/* Alright, Wilbur. */
       return;
diff -Nurd glibc-2.4/ports/sysdeps/hppa/dl-tls.h glibc-2.4/ports/sysdeps/hppa/dl-tls.h
--- glibc-2.4/ports/sysdeps/hppa/dl-tls.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/dl-tls.h	2006-04-22 04:21:00.000000000 +0200
@@ -0,0 +1,29 @@
+/* Thread-local storage handling in the ELF dynamic linker.  hppa version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+
+extern void *__tls_get_addr (tls_index *ti);
diff -Nurd glibc-2.4/ports/sysdeps/hppa/dl-trampoline.S glibc-2.4/ports/sysdeps/hppa/dl-trampoline.S
--- glibc-2.4/ports/sysdeps/hppa/dl-trampoline.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/dl-trampoline.S	2006-05-15 01:54:47.000000000 +0200
@@ -0,0 +1,197 @@
+/* PLT trampolines. hppa version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* This code gets called via the .plt stub, and is used in
+   dl-runtime.c to call the `_dl_fixup' function and then redirect 
+   to the    address it returns. `_dl_fixup' takes two
+   arguments, however `_dl_profile_fixup' takes a number of 
+   parameters for use with library auditing (LA).
+   
+   WARNING: This template is also used by gcc's __cffc, and expects
+   that the "bl" for _dl_runtime_resolve exist at a particular offset.
+   Do not change this template without changing gcc, while the prefix
+   "bl" should fix everything so gcc finds the right spot, it will
+   slow down __cffc when it attempts to call fixup to resolve function
+   descriptor references. Please refer to gcc/gcc/config/pa/fptr.c
+   
+   Enter with r19 = reloc offset, r20 = got-8, r21 = fixup ltp.  */
+
+	/* FAKE bl to provide gcc's __cffc with fixup loc. */
+	.text
+	bl	_dl_fixup, %r2
+        .text
+        .align 4
+        .global _dl_runtime_resolve
+        .type _dl_runtime_resolve,@function
+_dl_runtime_resolve:
+        .PROC
+        .CALLINFO FRAME=128,CALLS,SAVE_RP,ENTRY_GR=3
+        .ENTRY
+        /* SAVE_RP says we do */
+        stw %rp, -20(%sp)
+
+	/* Save static link register */
+	stw	%r29,-16(%sp)
+ 	/* Save argument registers in the call stack frame. */
+	stw	%r26,-36(%sp)
+	stw	%r25,-40(%sp)
+	stw	%r24,-44(%sp)
+	stw	%r23,-48(%sp)
+
+	/* Build a call frame, and save structure pointer. */
+	copy	%sp, %r26	/* Copy previous sp */
+	/* Save function result address (on entry) */
+	stwm	%r28,128(%sp)
+
+	/* Save floating point argument registers */
+	ldo	-56(%sp),%r26	
+	fstd,ma	%fr4,-8(%r26)
+	fstd,ma	%fr5,-8(%r26)
+	fstd,ma	%fr6,-8(%r26)
+	fstd	%fr7,0(%r26)
+
+	/* Fillin some frame info to follow ABI */
+	stw	%r21,-32(%sp)	/* PIC register value */
+	stw	%r26,-4(%sp)	/* Previous sp */
+
+ 	/* Set up args to fixup func, needs only two arguments  */
+	ldw	8+4(%r20),%r26		/* (1) got[1] == struct link_map */
+	copy	%r19,%r25		/* (2) reloc offset  */
+
+ 	/* Call the real address resolver. */
+	bl	_dl_fixup,%rp
+	copy	%r21,%r19		/* set fixup func ltp */
+
+	/* Load up the returned func descriptor */
+	copy	%ret0, %r22
+	copy	%ret1, %r19
+
+	/* Reload arguments fp args */
+	ldo	-80(%sp),%r26
+	fldd,ma	8(%r26),%fr7
+	fldd,ma	8(%r26),%fr6
+	fldd,ma	8(%r26),%fr5
+	fldd	0(%r26),%fr4
+
+	/* Adjust sp, and restore function result address*/
+	ldwm	-128(%sp),%r28
+
+	/* Reload static link register */
+	ldw	-16(%sp),%r29
+	/* Reload general args */
+	ldw	-36(%sp),%r26
+	ldw	-40(%sp),%r25
+	ldw	-44(%sp),%r24
+	ldw	-48(%sp),%r23
+
+	/* Jump to new function, but return to previous function */
+	bv	%r0(%r22)
+	ldw	-20(%sp),%rp
+        .EXIT
+        .PROCEND
+	.size   _dl_runtime_resolve, . - _dl_runtime_resolve
+
+
+	/* FIXME:
+		Need to largely rewrite the bottom half of
+		this code in order to save and restore the
+		LA struct from the stack along with
+		interpreted parameters.
+	*/
+        .text
+        .align 4
+        .global _dl_runtime_profile
+        .type _dl_runtime_profile,@function
+_dl_runtime_profile:
+        .PROC
+        .CALLINFO FRAME=128,CALLS,SAVE_RP,ENTRY_GR=3
+        .ENTRY
+
+        /* SAVE_RP says we do */
+        stw %rp, -20(%sp)
+
+	/* Save static link register */
+	stw	%r29,-16(%sp)
+ 	/* Save argument registers in the call stack frame. */
+	stw	%r26,-36(%sp)
+	stw	%r25,-40(%sp)
+	stw	%r24,-44(%sp)
+	stw	%r23,-48(%sp)
+
+	/* Build a call frame, and save structure pointer. */
+	copy	%sp, %r26	/* Copy previous sp */
+	/* Save function result address (on entry) */
+	stwm	%r28,128(%sp)
+
+	/* Save floating point argument registers */
+	ldo	-56(%sp),%r26	
+	fstd,ma	%fr4,-8(%r26)
+	fstd,ma	%fr5,-8(%r26)
+	fstd,ma	%fr6,-8(%r26)
+	fstd	%fr7,0(%r26)
+
+	/* Fillin some frame info to follow ABI */
+	stw	%r21,-32(%sp)	/* PIC register value */
+	stw	%r26,-4(%sp)	/* Previous sp */
+
+ 	/* Set up args to fixup func, needs five arguments  */
+	ldw	8+4(%r20),%r26		/* (1) got[1] == struct link_map */
+	copy	%r19,%r25		/* (2) reloc offset  */
+	copy    %rp,%r24		/* (3) profile_fixup needs rp */
+	copy	%r0,%r23		/* (4) regs */
+	ldo	-56(%sp), %r1
+	stw	%r1, -52(%sp)		/* (5) long int *framesizep */
+
+ 	/* Call the real address resolver. */
+	bl	_dl_profile_fixup,%rp
+	copy	%r21,%r19		/* set fixup func ltp */
+
+	/* Load up the returned func descriptor */
+	copy	%ret0, %r22
+	copy	%ret1, %r19
+
+	/* Reload arguments fp args */
+	ldo	-80(%sp),%r26
+	fldd,ma	8(%r26),%fr7
+	fldd,ma	8(%r26),%fr6
+	fldd,ma	8(%r26),%fr5
+	fldd	0(%r26),%fr4
+
+	/* Adjust sp, and restore function result address*/
+	ldwm	-128(%sp),%r28
+
+	/* Reload static link register */
+	ldw	-16(%sp),%r29
+	/* Reload general args */
+	ldw	-36(%sp),%r26
+	ldw	-40(%sp),%r25
+	ldw	-44(%sp),%r24
+	ldw	-48(%sp),%r23
+
+	/* Jump to new function, but return to previous function */
+	bv	%r0(%r22)
+	ldw	-20(%sp),%rp
+        .EXIT
+        .PROCEND
+	.size   _dl_runtime_profile, . - _dl_runtime_profile
+
+
+
diff -Nurd glibc-2.4/ports/sysdeps/hppa/elf/configure glibc-2.4/ports/sysdeps/hppa/elf/configure
--- glibc-2.4/ports/sysdeps/hppa/elf/configure	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/elf/configure	2006-04-22 04:21:00.000000000 +0200
@@ -0,0 +1,63 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/hppa/elf.
+
+if test "$usetls" != no; then
+# Check for support of thread-local storage handling in assembler and
+# linker.
+echo "$as_me:$LINENO: checking for hppa TLS support" >&5
+echo $ECHO_N "checking for hppa TLS support... $ECHO_C" >&6
+if test "${libc_cv_hppa_tls+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat > conftest.s <<\EOF
+; Setup tls data
+.section ".tdata","awT",@progbits
+foo:	.data	32
+	.text
+; Test general dyanmic relocations
+test0:
+	addil 	LT'foo-$tls_gdidx$, %r19
+	ldo 	RT'foo-$tls_gdidx$(%r1), %r26
+	b 	__tls_get_addr
+	nop
+; Test local dynamic relocations
+test1:
+	addil 	LT'foo-$tls_ldidx$, %r19
+	b 	__tls_get_addr
+	ldo 	RT'foo-$tls_ldidx$(%r1), %r26
+	ldo 	RR'foo-$tls_dtpoff$(%r1), %r25
+	; More variables can be loaded...
+; Test initial exec reloctiosn
+test2:
+	mfctl 	%cr27, %r26
+	addil 	LT'foo-$tls_ieoff$, %r19
+	ldw 	RT'foo-$tls_ieoff$(%r1), %r25
+	add 	%r26, %r25, %r24
+; Test local exec relocations
+test3:
+	mfctl 	%cr27, %r26
+	addil 	LR'foo-$tls_leoff$, %r26
+	ldo 	RR'foo-$tls_leoff$(%r1), %r25
+; Done all the TLS tests.
+EOF
+if { ac_try='${CC-cc} -c $CFLAGS conftest.s 1>&5'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  libc_cv_hppa_tls=yes
+else
+  libc_cv_hppa_tls=no
+fi
+rm -f conftest*
+fi
+echo "$as_me:$LINENO: result: $libc_cv_hppa_tls" >&5
+echo "${ECHO_T}$libc_cv_hppa_tls" >&6
+if test $libc_cv_hppa_tls = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_TLS_SUPPORT 1
+_ACEOF
+
+fi
+fi
diff -Nurd glibc-2.4/ports/sysdeps/hppa/elf/configure.in glibc-2.4/ports/sysdeps/hppa/elf/configure.in
--- glibc-2.4/ports/sysdeps/hppa/elf/configure.in	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/elf/configure.in	2006-04-22 04:21:00.000000000 +0200
@@ -0,0 +1,49 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/hppa/elf.
+
+if test "$usetls" != no; then
+# Check for support of thread-local storage handling in assembler and
+# linker.
+AC_CACHE_CHECK(for hppa TLS support, libc_cv_hppa_tls, [dnl
+cat > conftest.s <<\EOF
+; Setup tls data
+.section ".tdata","awT",@progbits
+foo:	.data	32 
+	.text
+; Test general dyanmic relocations
+test0:
+	addil 	LT'foo-$tls_gdidx$, %r19	
+	ldo 	RT'foo-$tls_gdidx$(%r1), %r26
+	b 	__tls_get_addr
+	nop
+; Test local dynamic relocations
+test1:
+	addil 	LT'foo-$tls_ldidx$, %r19
+	b 	__tls_get_addr
+	ldo 	RT'foo-$tls_ldidx$(%r1), %r26
+	ldo 	RR'foo-$tls_dtpoff$(%r1), %r25
+	; More variables can be loaded...
+; Test initial exec reloctiosn
+test2:
+	mfctl 	%cr27, %r26
+	addil 	LT'foo-$tls_ieoff$, %r19
+	ldw 	RT'foo-$tls_ieoff$(%r1), %r25
+	add 	%r26, %r25, %r24
+; Test local exec relocations
+test3:
+	mfctl 	%cr27, %r26
+	addil 	LR'foo-$tls_leoff$, %r26 
+	ldo 	RR'foo-$tls_leoff$(%r1), %r25
+; Done all the TLS tests.
+EOF
+dnl
+if AC_TRY_COMMAND(${CC-cc} -c $CFLAGS conftest.s 1>&AS_MESSAGE_LOG_FD); then
+  libc_cv_hppa_tls=yes
+else
+  libc_cv_hppa_tls=no
+fi
+rm -f conftest*])
+if test $libc_cv_hppa_tls = yes; then
+  AC_DEFINE(HAVE_TLS_SUPPORT)
+fi
+fi
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/bits/fenv.h glibc-2.4/ports/sysdeps/hppa/fpu/bits/fenv.h
--- glibc-2.4/ports/sysdeps/hppa/fpu/bits/fenv.h	2001-07-06 06:55:52.000000000 +0200
+++ glibc-2.4/ports/sysdeps/hppa/fpu/bits/fenv.h	2006-04-21 02:27:20.000000000 +0200
@@ -62,7 +62,12 @@
 
 /* Type representing floating-point environment.  This structure
    corresponds to the layout of the status and exception words in the
-   register file. */
+   register file. The exception registers are never saved/stored by
+   userspace. This structure is also not correctly aligned ever, in
+   an ABI error we left out __aligned(8) and subsequently all of our
+   fenv functions must accept unaligned input, align the input, and
+   then use assembly to store fr0. This is a performance hit, but 
+   means the ABI is stable. */
 typedef struct
 {
   unsigned int __status_word;
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/fclrexcpt.c glibc-2.4/ports/sysdeps/hppa/fpu/fclrexcpt.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/fclrexcpt.c	2003-12-18 04:56:15.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/fpu/fclrexcpt.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,14 +23,13 @@
 int
 feclearexcept (int excepts)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2]; } s;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
-
+  __asm__ ("fstd %%fr0,0(%1)" : "=m" (s.l) : "r" (&s.l) : "%r0");
   /* Clear all the relevant bits. */
-  sw[0] &= ~((excepts & FE_ALL_EXCEPT) << 27);
-  __asm__ ("fldd 0(%0),%%fr0" : : "r" (sw));
+  s.sw[0] &= ~((excepts & FE_ALL_EXCEPT) << 27);
+  __asm__ ("fldd 0(%0),%%fr0" : : "r" (&s.l), "m" (s.l) : "%r0");
 
   /* Success.  */
   return 0;
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/fedisblxcpt.c glibc-2.4/ports/sysdeps/hppa/fpu/fedisblxcpt.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/fedisblxcpt.c	2001-07-06 06:55:52.000000000 +0200
+++ glibc-2.4/ports/sysdeps/hppa/fpu/fedisblxcpt.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,15 +23,16 @@
 int
 fedisableexcept (int excepts)
 {
-  unsigned int sw[2], old_exc;
+  union { unsigned long long l; unsigned int sw[2]; } s; 
+  unsigned int old_exc;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)" : "=m" (s.l) : "r" (&s.l) : "%r0");
 
-  old_exc = sw[0] & FE_ALL_EXCEPT;
+  old_exc = s.sw[0] & FE_ALL_EXCEPT;
 
-  sw[0] &= ~(excepts & FE_ALL_EXCEPT);
-  __asm__ ("fldd 0(%0),%%fr0" : : "r" (sw));
+  s.sw[0] &= ~(excepts & FE_ALL_EXCEPT);
+  __asm__ ("fldd 0(%0),%%fr0" : : "r" (&s.l), "m" (s.l) : "%r0");
 
   return old_exc;
 }
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/feenablxcpt.c glibc-2.4/ports/sysdeps/hppa/fpu/feenablxcpt.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/feenablxcpt.c	2001-07-06 06:55:52.000000000 +0200
+++ glibc-2.4/ports/sysdeps/hppa/fpu/feenablxcpt.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,15 +23,16 @@
 int
 feenableexcept (int excepts)
 {
-  unsigned int sw[2], old_exc;
+  union { unsigned long long l; unsigned int sw[2]; } s;
+  unsigned int old_exc;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)" : "=m" (s.l) : "r" (&s.l) : "%r0");
 
-  old_exc = sw[0] & FE_ALL_EXCEPT;
+  old_exc = s.sw[0] & FE_ALL_EXCEPT;
 
-  sw[0] |= (excepts & FE_ALL_EXCEPT);
-  __asm__ ("fldd 0(%0),%%fr0" : : "r" (sw));
+  s.sw[0] |= (excepts & FE_ALL_EXCEPT);
+  __asm__ ("fldd 0(%0),%%fr0" : : "r" (&s.l), "m" (s.l) : "%r0");
 
   return old_exc;
 }
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/fegetenv.c glibc-2.4/ports/sysdeps/hppa/fpu/fegetenv.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/fegetenv.c	2003-12-18 04:56:50.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/fpu/fegetenv.c	2006-04-21 02:27:20.000000000 +0200
@@ -19,15 +19,17 @@
    02111-1307 USA.  */
 
 #include <fenv.h>
+#include <string.h>
 
 int
 fegetenv (fenv_t *envp)
 {
+  unsigned long long buf[4], *bufptr = buf;
+  
   __asm__ (
-	   "fstd,ma %%fr0,8(%1)\n"
-	   "fstd,ma %%fr1,8(%1)\n"
-	   "fstd,ma %%fr2,8(%1)\n"
-	   "fstd %%fr3,0(%1)\n"
-	   : "=m" (*envp), "+r" (envp));
+	   "fstd,ma %%fr0,8(%1)	\n\t"
+	   "fldd -8(%1),%%fr0	\n\t"
+	   : "=m" (buf), "+r" (bufptr) : : "%r0");
+  memcpy(envp, buf, sizeof (*envp));
   return 0;
 }
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/fegetexcept.c glibc-2.4/ports/sysdeps/hppa/fpu/fegetexcept.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/fegetexcept.c	2001-07-06 06:55:52.000000000 +0200
+++ glibc-2.4/ports/sysdeps/hppa/fpu/fegetexcept.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,10 +23,12 @@
 int
 fegetexcept (void)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2] } s;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)	\n\t" 
+           "fldd 0(%1),%%fr0	\n\t"
+      	   : "=m" (s.l) : "r" (&s.l) : "%r0");
 
-  return sw[0] & FE_ALL_EXCEPT;
+  return (s.sw[0] & FE_ALL_EXCEPT);
 }
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/fegetround.c glibc-2.4/ports/sysdeps/hppa/fpu/fegetround.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/fegetround.c	2001-07-06 06:55:52.000000000 +0200
+++ glibc-2.4/ports/sysdeps/hppa/fpu/fegetround.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,10 +23,12 @@
 int
 fegetround (void)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2] } s;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)	\n\t" 
+	   "fldd 0(%1),%%fr0	\n\t" 
+           : "=m" (s.l) : "r" (&s.l));
 
-  return sw[0] & FE_DOWNWARD;
+  return (s.sw[0] & FE_DOWNWARD);
 }
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/feholdexcpt.c glibc-2.4/ports/sysdeps/hppa/fpu/feholdexcpt.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/feholdexcpt.c	2004-02-21 03:10:01.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/fpu/feholdexcpt.c	2006-04-21 02:27:20.000000000 +0200
@@ -24,33 +24,32 @@
 int
 feholdexcept (fenv_t *envp)
 {
-  fenv_t clear;
-  fenv_t * _regs = envp;
+  union { unsigned long long buf[4]; fenv_t env; } clear;
+  unsigned long long *bufptr;
 
   /* Store the environment.  */
+  bufptr = clear.buf;
   __asm__ (
 	   "fstd,ma %%fr0,8(%1)\n"
-	   "fstd,ma %%fr1,8(%1)\n"
-	   "fstd,ma %%fr2,8(%1)\n"
-	   "fstd %%fr3,0(%1)\n"
-	   : "=m" (*_regs), "+r" (_regs));
-  memcpy (&clear, envp, sizeof (clear));
-
-  /* Now clear all exceptions.  */
-  clear.__status_word &= ~(FE_ALL_EXCEPT << 27);
-  memset (clear.__exception, 0, sizeof (clear.__exception));
+	   : "=m" (clear), "+r" (bufptr) : : "%r0");
+  memcpy (envp, &clear.env, sizeof (fenv_t));
 
+  /* Clear exception queues */
+  memset (clear.env.__exception, 0, sizeof (clear.env.__exception));
   /* And set all exceptions to non-stop.  */
-  clear.__status_word &= ~FE_ALL_EXCEPT;
+  clear.env.__status_word &= ~FE_ALL_EXCEPT;
+  /* Now clear all flags  */
+  clear.env.__status_word &= ~(FE_ALL_EXCEPT << 27);
 
-  /* Load the new environment. */
-  _regs = &clear;
+  /* Load the new environment. Note: fr0 must load last to enable T-bit 
+     Thus we start bufptr at the end and work backwards */
+  bufptr = (unsigned int)(clear.buf) + sizeof(unsigned int)*4;
   __asm__ (
-	   "fldd,ma 8(%0),%%fr0\n"
-	   "fldd,ma 8(%0),%%fr1\n"
-	   "fldd,ma 8(%0),%%fr2\n"
-	   "fldd 0(%0),%%fr3\n"
-	   : : "r" (_regs));
+	   "fldd,mb -8(%0),%%fr0\n"
+	   : : "r" (bufptr), "m" (clear) : "%r0");
 
   return 0;
 }
+
+libm_hidden_def (feholdexcept)
+
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/fesetenv.c glibc-2.4/ports/sysdeps/hppa/fpu/fesetenv.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/fesetenv.c	2003-12-18 04:57:31.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/fpu/fesetenv.c	2006-04-21 02:27:20.000000000 +0200
@@ -25,40 +25,38 @@
 int
 fesetenv (const fenv_t *envp)
 {
-  fenv_t temp;
-  fenv_t * _regs = &temp;
+  union { unsigned long long buf[4]; fenv_t env; } temp;
+  unsigned long long *bufptr;
 
   /* Install the environment specified by ENVP.  But there are a few
      values which we do not want to come from the saved environment.
      Therefore, we get the current environment and replace the values
      we want to use from the environment specified by the parameter.  */
+  bufptr = temp.buf;
   __asm__ (
 	   "fstd,ma %%fr0,8(%1)\n"
-	   "fstd,ma %%fr1,8(%1)\n"
-	   "fstd,ma %%fr2,8(%1)\n"
-	   "fstd %%fr3,0(%1)\n"
-	   : "=m" (*_regs), "+r" (_regs));
+	   : "=m" (temp), "+r" (bufptr) : : "%r0");
 
-  temp.__status_word &= ~(FE_ALL_EXCEPT
-			  | (FE_ALL_EXCEPT << 27)
-			  | FE_DOWNWARD);
+  temp.env.__status_word &= ~(FE_ALL_EXCEPT
+			    | (FE_ALL_EXCEPT << 27)
+			    | FE_DOWNWARD);
   if (envp == FE_DFL_ENV)
     ;
   else if (envp == FE_NOMASK_ENV)
-    temp.__status_word |= FE_ALL_EXCEPT;
+    temp.env.__status_word |= FE_ALL_EXCEPT;
   else
-    temp.__status_word |= (envp->__status_word
-			   & (FE_ALL_EXCEPT
-			      | FE_DOWNWARD
-			      | (FE_ALL_EXCEPT << 27)));
+    temp.env.__status_word |= (envp->__status_word
+			       & (FE_ALL_EXCEPT
+				  | FE_DOWNWARD
+				  | (FE_ALL_EXCEPT << 27)));
 
-  /* Load the new environment. */
+  /* Load the new environment. We use bufptr again since the 
+     initial asm has modified the value of the register and here
+     we take advantage of that to load in reverse order so fr0
+     is loaded last and T-Bit is enabled. */
   __asm__ (
-	   "fldd,ma -8(%1),%%fr3\n"
-	   "fldd,ma -8(%1),%%fr2\n"
-	   "fldd,ma -8(%1),%%fr1\n"
-	   "fldd 0(%1),%%fr0\n"
-	   : "=m" (*_regs), "+r" (_regs));
+	   "fldd,mb -8(%1),%%fr0\n"
+	   : "=m" (temp), "+r" (bufptr) : : "%r0" );
 
   /* Success.  */
   return 0;
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/fesetround.c glibc-2.4/ports/sysdeps/hppa/fpu/fesetround.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/fesetround.c	2002-12-03 03:50:52.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/fpu/fesetround.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,17 +23,19 @@
 int
 fesetround (int round)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2]; } s;
 
   if (round & ~FE_DOWNWARD)
-    /* ROUND is not a valid rounding mode.  */
+    /* round is not a valid rounding mode. */
     return 1;
-
+  
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
-  sw[0] &= ~FE_DOWNWARD;
-  sw[0] |= round;
-  __asm__ ("fldd 0(%0),%%fr0" : : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)" : "=m" (s.l) : "r" (&s.l) : "%r0");
+  s.sw[0] &= ~FE_DOWNWARD;
+  s.sw[0] |= round & FE_DOWNWARD;
+  __asm__ ("fldd 0(%0),%%fr0" : : "r" (&s.l), "m" (s.l) : "%r0");
 
   return 0;
 }
+
+libm_hidden_def (fesetround)
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/feupdateenv.c glibc-2.4/ports/sysdeps/hppa/fpu/feupdateenv.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/feupdateenv.c	2004-04-18 00:51:43.000000000 +0200
+++ glibc-2.4/ports/sysdeps/hppa/fpu/feupdateenv.c	2006-04-21 02:27:20.000000000 +0200
@@ -19,19 +19,22 @@
    02111-1307 USA.  */
 
 #include <fenv.h>
+#include <string.h>
 
 int
 feupdateenv (const fenv_t *envp)
 {
-  unsigned int sw[2];
-
-  /* Get the current exception status. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  union { unsigned long long l; unsigned int sw[2]; } s;
+  fenv_t temp;
+  /* Get the current exception status */
+  __asm__ ("fstd %%fr0,0(%1)	\n\t" 
+           "fldd 0(%1),%%fr0	\n\t" 
+	   : "=m" (s.l) : "r" (&s.l));
+  memcpy(&temp, envp, sizeof(fenv_t));
+  /* Currently raised exceptions not cleared */
+  temp.__status_word |= s.sw[0] & (FE_ALL_EXCEPT << 27);
   /* Install new environment.  */
-  fesetenv (envp);
-  /* Raise the saved exceptions */
-  feraiseexcept(sw[0] & FE_ALL_EXCEPT);
-
+  fesetenv (&temp);
   /* Success.  */
   return 0;
 }
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/fgetexcptflg.c glibc-2.4/ports/sysdeps/hppa/fpu/fgetexcptflg.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/fgetexcptflg.c	2001-07-06 06:55:52.000000000 +0200
+++ glibc-2.4/ports/sysdeps/hppa/fpu/fgetexcptflg.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,12 +23,14 @@
 int
 fegetexceptflag (fexcept_t *flagp, int excepts)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2]; } s;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)	\n\t" 
+           "fldd 0(%1),%%fr0	\n\t" 
+      	   : "=m" (s.l) : "r" (&s.l) : "%r0");
 
-  *flagp = (sw[0] >> 27) & excepts & FE_ALL_EXCEPT;
+  *flagp = (s.sw[0] >> 27) & excepts & FE_ALL_EXCEPT;
 
   /* Success.  */
   return 0;
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/fsetexcptflg.c glibc-2.4/ports/sysdeps/hppa/fpu/fsetexcptflg.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/fsetexcptflg.c	2003-12-18 04:58:26.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/fpu/fsetexcptflg.c	2006-04-21 02:27:20.000000000 +0200
@@ -24,16 +24,14 @@
 int
 fesetexceptflag (const fexcept_t *flagp, int excepts)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2]; } s;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
-
-  /* Install new enable trap bits  */
-  sw[0] |= (*flagp & excepts & FE_ALL_EXCEPT) << 27;
-
+  __asm__ ("fstd %%fr0,0(%1)" : "=m" (s.l) : "r" (&s.l) : "%r0");
+  /* Install new raised trap bits */
+  s.sw[0] |= (*flagp & excepts & FE_ALL_EXCEPT) << 27;
   /* Store the new status word.  */
-  __asm__ ("fldd 0(%0),%%fr0" : : "r" (sw));
+  __asm__ ("fldd 0(%0),%%fr0" : : "r" (&s.l), "m" (s.l) : "%r0");
 
   /* Success.  */
   return 0;
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/ftestexcept.c glibc-2.4/ports/sysdeps/hppa/fpu/ftestexcept.c
--- glibc-2.4/ports/sysdeps/hppa/fpu/ftestexcept.c	2001-07-06 06:55:52.000000000 +0200
+++ glibc-2.4/ports/sysdeps/hppa/fpu/ftestexcept.c	2006-04-21 02:27:20.000000000 +0200
@@ -23,10 +23,12 @@
 int
 fetestexcept (int excepts)
 {
-  unsigned int sw[2];
+  union { unsigned long long l; unsigned int sw[2] } s;
 
   /* Get the current status word. */
-  __asm__ ("fstd %%fr0,0(%1)" : "=m" (*sw) : "r" (sw));
+  __asm__ ("fstd %%fr0,0(%1)	\n\t" 
+           "fldd 0(%1),%%fr0	\n\t" 
+      	   : "=m" (s.l) : "r" (&s.l));
 
-  return (sw[0] >> 27) & excepts & FE_ALL_EXCEPT;
+  return (s.sw[0] >> 27) & excepts & FE_ALL_EXCEPT;
 }
diff -Nurd glibc-2.4/ports/sysdeps/hppa/fpu/libm-test-ulps glibc-2.4/ports/sysdeps/hppa/fpu/libm-test-ulps
--- glibc-2.4/ports/sysdeps/hppa/fpu/libm-test-ulps	2006-01-15 18:59:37.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/fpu/libm-test-ulps	2006-04-21 02:27:20.000000000 +0200
@@ -1,6 +1,9 @@
 # Begin of automatic generation
 
 # atan2
+Test "atan2 (-0.00756827042671106339, -.001792735857538728036) == -1.80338464113663849327153994380":
+float: 6
+ifloat: 6
 Test "atan2 (-0.75, -1.0) == -2.49809154479650885165983415456218025":
 float: 3
 ifloat: 3
@@ -258,9 +261,6 @@
 ifloat: 1
 
 # ctan
-Test "Real part of: ctan (-2 - 3 i) == 0.376402564150424829275122113032269084e-2 - 1.00323862735360980144635859782192726 i":
-double: 1
-idouble: 1
 Test "Imaginary part of: ctan (0.75 + 1.25 i) == 0.160807785916206426725166058173438663 + 0.975363285031235646193581759755216379 i":
 double: 1
 idouble: 1
@@ -479,6 +479,11 @@
 float: 1
 ifloat: 1
 
+# lround
+Test "lround (1071930.0008) == 1071930":
+double: -214511494
+idouble: -214511494
+
 # sincos
 Test "sincos (M_PI_6l*2.0, &sin_res, &cos_res) puts 0.5 in cos_res":
 double: 1
@@ -640,8 +645,8 @@
 
 # Maximal error of functions:
 Function: "atan2":
-float: 3
-ifloat: 3
+float: 6
+ifloat: 6
 
 Function: "atanh":
 float: 1
@@ -777,10 +782,6 @@
 float: 1
 ifloat: 1
 
-Function: Real part of "ctan":
-double: 1
-idouble: 1
-
 Function: Imaginary part of "ctan":
 double: 1
 idouble: 1
diff -Nurd glibc-2.4/ports/sysdeps/hppa/hppa1.1/Implies glibc-2.4/ports/sysdeps/hppa/hppa1.1/Implies
--- glibc-2.4/ports/sysdeps/hppa/hppa1.1/Implies	2000-10-15 05:25:29.000000000 +0200
+++ glibc-2.4/ports/sysdeps/hppa/hppa1.1/Implies	2006-08-06 09:40:19.000000000 +0200
@@ -1,4 +1,3 @@
 wordsize-32
 ieee754/flt-32
 ieee754/dbl-64
-ieee754/ldbl-128
diff -Nurd glibc-2.4/ports/sysdeps/hppa/ldsodefs.h glibc-2.4/ports/sysdeps/hppa/ldsodefs.h
--- glibc-2.4/ports/sysdeps/hppa/ldsodefs.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/ldsodefs.h	2006-05-24 17:31:25.000000000 +0200
@@ -0,0 +1,42 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _HPPA_LDSODEFS_H
+#define _HPPA_LDSODEFS_H 1
+
+#include <elf.h>
+
+struct La_hppa_regs;
+struct La_hppa_retval;
+
+#define ARCH_PLTENTER_MEMBERS \
+    Elf32_Addr (*hppa_gnu_pltenter) (Elf32_Sym *, unsigned int, uintptr_t *,	\
+				     uintptr_t *, struct La_hppa_regs *,	\
+				     unsigned int *, const char *name,		\
+				     long int *framesizep);
+
+#define ARCH_PLTEXIT_MEMBERS \
+    unsigned int (*hppa_gnu_pltexit) (Elf32_Sym *, unsigned int, uintptr_t *,	\
+				      uintptr_t *,				\
+				      const struct La_hppa_regs *,		\
+				      struct La_hppa_retval *, const char *);
+
+#include_next <ldsodefs.h>
+
+#endif
diff -Nurd glibc-2.4/ports/sysdeps/hppa/libc-tls.c glibc-2.4/ports/sysdeps/hppa/libc-tls.c
--- glibc-2.4/ports/sysdeps/hppa/libc-tls.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/libc-tls.c	2006-04-22 04:21:00.000000000 +0200
@@ -0,0 +1,38 @@
+/* Thread-local storage handling in the ELF dynamic linker.  hppa version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <csu/libc-tls.c>
+#include <dl-tls.h>
+
+#if USE_TLS
+
+/* On hppa, linker optimizations are not required, so __tls_get_addr
+   can be called even in statically linked binaries.  In this case module
+   must be always 1 and PT_TLS segment exist in the binary, otherwise it
+   would not link.  */
+
+void *
+__tls_get_addr (tls_index *ti)
+{
+  dtv_t *dtv = THREAD_DTV ();
+  return (char *) dtv[1].pointer.val + ti->ti_offset;
+}
+
+#endif
+
diff -Nurd glibc-2.4/ports/sysdeps/hppa/linuxthreads/pspinlock.c glibc-2.4/ports/sysdeps/hppa/linuxthreads/pspinlock.c
--- glibc-2.4/ports/sysdeps/hppa/linuxthreads/pspinlock.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/linuxthreads/pspinlock.c	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,82 @@
+/* POSIX spinlock implementation.  hppa version.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include "internals.h"
+
+int
+__pthread_spin_lock (pthread_spinlock_t *lock)
+{
+  volatile unsigned int *addr = __ldcw_align (lock);
+
+  while (__ldcw (addr) == 0)
+    while (*addr == 0) ;
+
+  return 0;
+}
+weak_alias (__pthread_spin_lock, pthread_spin_lock)
+
+
+int
+__pthread_spin_trylock (pthread_spinlock_t *lock)
+{
+  volatile unsigned int *a = __ldcw_align (lock);
+
+  return __ldcw (a) ? 0 : EBUSY;
+}
+weak_alias (__pthread_spin_trylock, pthread_spin_trylock)
+
+
+int
+__pthread_spin_unlock (pthread_spinlock_t *lock)
+{
+  volatile unsigned int *a = __ldcw_align (lock);
+  int tmp = 1;
+  /* This should be a memory barrier to newer compilers */
+  __asm__ __volatile__ ("stw,ma %1,0(%0)"
+                        : : "r" (a), "r" (tmp) : "memory");           
+  return 0;
+}
+weak_alias (__pthread_spin_unlock, pthread_spin_unlock)
+
+
+int
+__pthread_spin_init (pthread_spinlock_t *lock, int pshared)
+{
+  /* We can ignore the `pshared' parameter.  Since we are busy-waiting
+     all processes which can access the memory location `lock' points
+     to can use the spinlock.  */
+  volatile unsigned int *a = __ldcw_align (lock);
+  int tmp = 1;
+  /* This should be a memory barrier to newer compilers */
+  __asm__ __volatile__ ("stw,ma %1,0(%0)"
+                        : : "r" (a), "r" (tmp) : "memory");           
+  return 0;
+}
+weak_alias (__pthread_spin_init, pthread_spin_init)
+
+
+int
+__pthread_spin_destroy (pthread_spinlock_t *lock)
+{
+  /* Nothing to do.  */
+  return 0;
+}
+weak_alias (__pthread_spin_destroy, pthread_spin_destroy)
diff -Nurd glibc-2.4/ports/sysdeps/hppa/linuxthreads/pt-machine.h glibc-2.4/ports/sysdeps/hppa/linuxthreads/pt-machine.h
--- glibc-2.4/ports/sysdeps/hppa/linuxthreads/pt-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/linuxthreads/pt-machine.h	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,134 @@
+/* Machine-dependent pthreads configuration and inline functions.
+   hppa version.
+   Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Richard Henderson <rth@tamu.edu>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
+#include <sys/types.h>
+#include <bits/initspin.h>
+
+#ifndef PT_EI
+# define PT_EI extern inline __attribute__ ((always_inline))
+#endif
+
+extern inline long int testandset (__atomic_lock_t *spinlock);
+extern inline int __compare_and_swap (long int *p, long int oldval, long int newval);
+extern inline int lock_held (__atomic_lock_t *spinlock); 
+extern inline int __load_and_clear (__atomic_lock_t *spinlock);
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("%r30");
+
+/* Get/Set thread-specific pointer.  We have to call into the kernel to
+ * modify it, but we can read it in user mode.  */
+#ifndef THREAD_SELF
+#define THREAD_SELF __get_cr27()
+#endif
+
+#ifndef SET_THREAD_SELF
+#define SET_THREAD_SELF(descr) __set_cr27(descr)
+#endif
+/* Use this to determine type */
+struct _pthread_descr_struct *__thread_self;
+
+static inline struct _pthread_descr_struct * __get_cr27(void)
+{
+  long cr27;
+  asm ("mfctl %%cr27, %0" : "=r" (cr27) : );
+  return (struct _pthread_descr_struct *) cr27;
+}
+
+#ifndef INIT_THREAD_SELF
+#define INIT_THREAD_SELF(descr, nr) __set_cr27(descr)
+#endif
+
+static inline void __set_cr27(struct _pthread_descr_struct * cr27)
+{
+  asm ( "ble	0xe0(%%sr2, %%r0)\n\t"
+	"copy	%0, %%r26"
+	: : "r" (cr27) : "r26" );
+}
+
+/* We want the OS to assign stack addresses.  */
+#define FLOATING_STACKS	1
+#define ARCH_STACK_MAX_SIZE	8*1024*1024
+
+/* The hppa only has one atomic read and modify memory operation,
+   load and clear, so hppa spinlocks must use zero to signify that
+   someone is holding the lock.  The address used for the ldcw
+   semaphore must be 16-byte aligned.  */
+#define __ldcw(a) \
+({ 									\
+  unsigned int __ret;							\
+  __asm__ __volatile__("ldcw 0(%1),%0"					\
+                      : "=r" (__ret) : "r" (a) : "memory");		\
+  __ret;								\
+})
+
+/* Strongly ordered lock reset */
+#define __lock_reset(lock_addr, tmp) \
+({										\
+	__asm__ __volatile__ ("stw,ma %1,0(%0)"					\
+				: : "r" (lock_addr), "r" (tmp) : "memory"); 	\
+})
+
+/* Because malloc only guarantees 8-byte alignment for malloc'd data,
+   and GCC only guarantees 8-byte alignment for stack locals, we can't
+   be assured of 16-byte alignment for atomic lock data even if we
+   specify "__attribute ((aligned(16)))" in the type declaration.  So,
+   we use a struct containing an array of four ints for the atomic lock
+   type and dynamically select the 16-byte aligned int from the array
+   for the semaphore.  */
+#define __PA_LDCW_ALIGNMENT 16
+#define __ldcw_align(a) ({ \
+  volatile unsigned int __ret = (unsigned int) a;			\
+  if ((__ret & ~(__PA_LDCW_ALIGNMENT - 1)) < (unsigned int) a)		\
+    __ret = (__ret & ~(__PA_LDCW_ALIGNMENT - 1)) + __PA_LDCW_ALIGNMENT; \
+  (unsigned int *) __ret;						\
+})
+
+/* Spinlock implementation; required.  */
+PT_EI int
+__load_and_clear (__atomic_lock_t *spinlock)
+{
+  volatile unsigned int *a = __ldcw_align (spinlock);
+
+  return __ldcw (a);
+}
+
+/* Emulate testandset */
+PT_EI long int
+testandset (__atomic_lock_t *spinlock)
+{
+  return (__load_and_clear(spinlock) == 0);
+}
+
+PT_EI int
+lock_held (__atomic_lock_t *spinlock)
+{
+  volatile unsigned int *a = __ldcw_align (spinlock);
+
+  return *a == 0;
+}
+		
+#endif /* pt-machine.h */
diff -Nurd glibc-2.4/ports/sysdeps/hppa/linuxthreads/tls.h glibc-2.4/ports/sysdeps/hppa/linuxthreads/tls.h
--- glibc-2.4/ports/sysdeps/hppa/linuxthreads/tls.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/linuxthreads/tls.h	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,163 @@
+/* Definition for thread-local data handling.  linuxthreads/hppa version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TLS_H
+#define _TLS_H
+
+#ifndef __ASSEMBLER__
+# include <pt-machine.h>
+# include <stdbool.h>
+# include <stddef.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+#else /* __ASSEMBLER__ */
+# include <tcb-offsets.h>
+#endif /* __ASSEMBLER__ */
+
+
+#if defined HAVE_TLS_SUPPORT 
+
+/* Signal that TLS support is available.  */
+# define USE_TLS	1
+
+# ifndef __ASSEMBLER__
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+} tcbhead_t;
+
+/* Include some syscall information for other headers */
+#  include <sysdep.h>
+
+/* This is the size of the initial TCB.  */
+#  define TLS_INIT_TCB_SIZE sizeof (tcbhead_t)
+
+/* Alignment requirements for the initial TCB.  */
+#  define TLS_INIT_TCB_ALIGN __alignof__ (tcbhead_t)
+
+/* This is the size of the TCB.  */
+#  define TLS_TCB_SIZE sizeof (tcbhead_t)
+
+/* This is the size we need before TCB.  */
+#  define TLS_PRE_TCB_SIZE sizeof (struct _pthread_descr_struct)
+
+/* Alignment requirements for the TCB.  */
+#  define TLS_TCB_ALIGN __alignof__ (struct _pthread_descr_struct)
+
+/* The TLS blocks start right after the TCB.  */
+#  define TLS_DTV_AT_TP	1
+
+/* Return the thread descriptor for the current thread.  */
+#  undef THREAD_SELF
+#  define THREAD_SELF 				\
+  ({ struct _pthread_descr_struct *__self;	\
+	__self = __get_cr27();			\
+   	__self - 1;				\
+   })
+
+#  undef INIT_THREAD_SELF
+#  define INIT_THREAD_SELF(descr, nr) 				\
+  ({ struct _pthread_descr_struct *__self = (void *)descr;	\
+	__set_cr27(__self + 1);					\
+   	0;							\
+   })
+
+/* Access to data in the thread descriptor is easy.  */
+#define THREAD_GETMEM(descr, member) \
+  ((void) sizeof (descr), THREAD_SELF->member)
+#define THREAD_GETMEM_NC(descr, member) \
+  ((void) sizeof (descr), THREAD_SELF->member)
+#define THREAD_SETMEM(descr, member, value) \
+  ((void) sizeof (descr), THREAD_SELF->member = (value))
+#define THREAD_SETMEM_NC(descr, member, value) \
+  ((void) sizeof (descr), THREAD_SELF->member = (value))
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+#  define INSTALL_DTV(tcbp, dtvp) \
+  ((tcbhead_t *) (tcbp))->dtv = dtvp + 1
+
+/* Install new dtv for current thread.  */
+#  define INSTALL_NEW_DTV(dtv) \
+  ({ tcbhead_t *__tcbp = (tcbhead_t *)__get_cr27();	\
+   	__tcbp->dtv = dtv;				\
+   })
+
+/* Return dtv of given thread descriptor.  */
+#  define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))->dtv)
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+#  define TLS_INIT_TP(tcbp, secondcall) \
+  ({ __set_cr27(tcbp); 0; })
+
+/* Return the address of the dtv for the current thread.  */
+#  define THREAD_DTV() 					\
+  ({ tcbhead_t *__tcbp = (tcbhead_t *)__get_cr27();	\
+   	__tcbp->dtv;					\
+   })
+
+# define TLS_MULTIPLE_THREADS_IN_TCB 1
+
+/* Get the thread descriptor definition.  This must be after the
+   the definition of THREAD_SELF for TLS.  */
+#  include <linuxthreads/descr.h>
+
+# endif /* __ASSEMBLER__ */
+
+#else
+
+# ifndef __ASSEMBLER__
+
+typedef struct
+{
+  void *tcb;
+  dtv_t *dtv;
+  void *self;
+  int multiple_threads;
+} tcbhead_t;
+
+/* Get the thread descriptor definition.  */
+#  include <linuxthreads/descr.h>
+
+#  define NONTLS_INIT_TP \
+  do { 									\
+    static const tcbhead_t nontls_init_tp = { .multiple_threads = 0 };	\
+    INIT_THREAD_SELF(&nontls_init_tp, 0);	      			\
+  } while (0)
+
+# endif /* __ASSEMBLER__ */
+
+#endif	/* HAVE_TLS_SUPPORT */
+
+#endif	/* tls.h */
diff -Nurd glibc-2.4/ports/sysdeps/hppa/sysdep.h glibc-2.4/ports/sysdeps/hppa/sysdep.h
--- glibc-2.4/ports/sysdeps/hppa/sysdep.h	2003-10-15 07:31:42.000000000 +0200
+++ glibc-2.4/ports/sysdeps/hppa/sysdep.h	2006-05-15 01:54:47.000000000 +0200
@@ -22,9 +22,8 @@
 #include <sys/syscall.h>
 #include "config.h"
 
-#ifndef ASM_LINE_SEP
-#define ASM_LINE_SEP ;
-#endif
+#undef ASM_LINE_SEP
+#define ASM_LINE_SEP ! 
 
 #ifdef	__ASSEMBLER__
 
@@ -51,13 +50,9 @@
 #define END(name)							      \
   .PROCEND
 
-
-/* If compiled for profiling, call `mcount' at the start of each function.  */
+/* GCC does everything for us. */
 #ifdef	PROF
-/* The mcount code relies on a normal frame pointer being on the stack
-   to locate our caller, so push one just for its benefit.  */
-#define CALL_MCOUNT \
-  XXX	ASM_LINE_SEP
+#define CALL_MCOUNT 
 #else
 #define CALL_MCOUNT		/* Do nothing.  */
 #endif
diff -Nurd glibc-2.4/ports/sysdeps/hppa/tls-macros.h glibc-2.4/ports/sysdeps/hppa/tls-macros.h
--- glibc-2.4/ports/sysdeps/hppa/tls-macros.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/tls-macros.h	2006-08-06 09:40:19.000000000 +0200
@@ -0,0 +1,115 @@
+/* TLS Access Macros for HP PARISC Linux */
+
+/* HPPA Local Exec TLS access.  */
+#define TLS_LE(x) \
+  ({  int * __result;  \
+      unsigned long __tmp; \
+      asm ( \
+	"  mfctl %%cr27, %1\n" \
+	"  addil LR'" #x "-$tls_leoff$, %1\n" \
+	"  ldo RR'" #x "-$tls_leoff$(%%r1), %0\n" \
+        : "=r" (__result), "=r" (__tmp) \
+	: \
+	: "r1" );  \
+      __result;  \
+  })
+
+/* HPPA Initial Exec TLS access.  */
+#ifdef PIC
+#  define TLS_IE(x) \
+  ({  int * __result;  \
+      unsigned long __tmp, __tmp2; \
+      asm ( \
+	"  mfctl %%cr27, %1\n" \
+	"  addil LT'" #x "-$tls_ieoff$, %%r19\n" \
+	"  ldw RT'" #x "-$tls_ieoff$(%%r1), %2\n" \
+	"  add %1, %2, %0\n" \
+	: "=r" (__result), "=r" (__tmp), "=r" (__tmp2) \
+	: \
+	: "r1" ); \
+      __result;  \
+  })
+#else
+#  define TLS_IE(x) \
+  ({  int * __result;  \
+      unsigned long __tmp, __tmp2; \
+      asm ( \
+	"  mfctl %%cr27, %1\n" \
+	"  addil LR'" #x "-$tls_ieoff$, %%r27\n" \
+	"  ldw RR'" #x "-$tls_ieoff$(%%r1), %2\n" \
+	"  add %1, %2, %0\n" \
+	: "=r" (__result), "=r" (__tmp), "=r" (__tmp2) \
+	: \
+	: "r1" ); \
+      __result;  \
+  })
+#endif
+
+#ifdef PIC
+/* HPPA Local Dynamic TLS access.  */
+#  define TLS_LD(x) \
+  ({  int * __result;  \
+      asm (  \
+	"  copy %%r19, %%r4\n" \
+	"  addil LT'" #x "-$tls_ldidx$, %%r19\n" \
+	"  bl __tls_get_addr, %%r2\n" \
+	"  ldo RT'" #x "-$tls_ldidx$(%%r1), %%r26\n" \
+	"  addil LR'" #x "-$tls_dtpoff$, %%r28\n" \
+	"  ldo RR'" #x "-$tls_dtpoff$(%%r1), %0\n" \
+	"  copy %%r4, %%r19\n" \
+	: "=r" (__result) \
+	: \
+	: "r1", "r2", "r4", "r20", "r21", "r22", "r23", "r24", \
+	  "r25", "r26", "r28", "r29", "r31" ); \
+      __result;  \
+  })
+#else
+#  define TLS_LD(x) \
+  ({  int * __result;  \
+      asm (  \
+	"  addil LR'" #x "-$tls_ldidx$, %%r27\n" \
+	"  bl __tls_get_addr, %%r2\n" \
+	"  ldo RR'" #x "-$tls_ldidx$(%%r1), %%r26\n" \
+	"  addil LR'" #x "-$tls_dtpoff$, %%r28\n" \
+	"  ldo RR'" #x "-$tls_dtpoff$(%%r1), %0\n" \
+	: "=r" (__result) \
+	: \
+	: "r1", "r2", "r20", "r21", "r22", "r23", "r24", \
+	  "r25", "r26", "r28", "r29", "r31" ); \
+      __result;  \
+  })
+#endif
+
+/* HPPA General Dynamic TLS access.  */
+#ifdef PIC
+#  define TLS_GD(x) \
+  ({  int * __result;  \
+      asm (  \
+	"  copy %%r19, %%r4\n" \
+        "  addil LT'" #x "-$tls_gdidx$, %%r19\n" \
+	"  bl __tls_get_addr, %%r2\n" \
+	"  ldo RT'" #x "-$tls_gdidx$(%%r1), %%r26\n" \
+	"  copy %%r28, %0\n" \
+	"  copy %%r4, %%r19\n" \
+	: "=r" (__result) \
+	: \
+	: "r1", "r2", "r4", "r20", "r21", "r22", "r23", "r24", \
+	  "r25", "r26", "r28", "r29", "r31" ); \
+      __result;  \
+  })
+#else
+#  define TLS_GD(x) \
+  ({  int * __result;  \
+      asm (  \
+        "  addil LR'" #x "-$tls_gdidx$, %%r27\n" \
+	"  bl __tls_get_addr, %%r2\n" \
+	"  ldo RR'" #x "-$tls_gdidx$(%%r1), %%r26\n" \
+	"  copy %%r28, %0\n" \
+	: "=r" (__result) \
+	: \
+	: "r1", "r2", "r20", "r21", "r22", "r23", "r24", \
+	  "r25", "r26", "r28", "r29", "r31" ); \
+      __result;  \
+  })
+#endif
+
diff -Nurd glibc-2.4/ports/sysdeps/hppa/tst-audit.h glibc-2.4/ports/sysdeps/hppa/tst-audit.h
--- glibc-2.4/ports/sysdeps/hppa/tst-audit.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/hppa/tst-audit.h	2006-07-16 20:31:20.000000000 +0200
@@ -0,0 +1,26 @@
+/* Definitions for testing PLT entry/exit auditing.  HP-PARISC version.
+
+   Copyright (C) 2006 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define pltenter la_hppa_gnu_pltenter
+#define pltexit la_hppa_gnu_pltexit
+#define La_regs La_hppa_regs
+#define La_retval La_hppa_retval
+#define int_retval lrv_r28
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/bits/atomic.h glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/bits/atomic.h
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/bits/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/bits/atomic.h	2006-06-09 03:25:30.000000000 +0200
@@ -0,0 +1,120 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@baldric.uwo.ca>, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdint.h>
+#include <sysdep.h>
+#include <abort-instr.h>
+#include <kernel-features.h>
+
+/* We need EFAULT, ENONSYS, and EAGAIN */
+#if !defined EFAULT && !defined ENOSYS && !defined EAGAIN
+#undef EFAULT
+#undef ENOSYS
+#undef EAGAIN
+#define EFAULT	14
+#define ENOSYS	251
+#define EAGAIN	11
+#endif
+
+#ifndef _BITS_ATOMIC_H
+#define _BITS_ATOMIC_H	1
+
+typedef int8_t atomic8_t;
+typedef uint8_t uatomic8_t;
+typedef int_fast8_t atomic_fast8_t;
+typedef uint_fast8_t uatomic_fast8_t;
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+/* prev = *addr;
+   if (prev == old)
+     *addr = new;
+   return prev; */
+
+/* Use the kernel atomic light weight syscalls on hppa */ 
+#define LWS "0xb0"
+#define LWS_CAS 0x0
+/* Note r31 is the link register */
+#define LWS_CLOBBER "r1", "r26", "r25", "r24", "r23", "r22", "r21", "r20", "r28", "r31", "memory"
+#define ASM_EAGAIN "11"
+
+#if __ASSUME_LWS_CAS
+/* The only basic operation needed is compare and exchange.  */
+# define atomic_compare_and_exchange_val_acq(mem, newval, oldval) 	\
+  ({									\
+     volatile int lws_errno = EFAULT;					\
+     volatile int lws_ret = 0xdeadbeef;					\
+     asm volatile(							\
+	"0:					\n\t"			\
+	"copy	%3, %%r26			\n\t"			\
+	"copy	%4, %%r25			\n\t"			\
+	"copy	%5, %%r24			\n\t"			\
+	"ble	" LWS "(%%sr2, %%r0)		\n\t"			\
+	"ldi	0, %%r20			\n\t"			\
+	"cmpib,=,n " ASM_EAGAIN ",%%r21,0	\n\t"			\
+	"nop					\n\t"			\
+	"stw	%%r28, %0			\n\t"			\
+        "sub	%%r0, %%r21, %%r21		\n\t"			\
+	"stw	%%r21, %1			\n\t"			\
+	: "=m" (lws_ret), "=m" (lws_errno), "=m" (*mem)			\
+        : "r" (mem), "r" (oldval), "r" (newval)				\
+	: LWS_CLOBBER							\
+     );									\
+    									\
+     if(lws_errno == EFAULT || lws_errno == ENOSYS)			\
+     	ABORT_INSTRUCTION;						\
+    									\
+     lws_ret;								\
+   })
+
+# define atomic_compare_and_exchange_bool_acq(mem, newval, oldval) 	\
+  ({									\
+     int ret;								\
+     ret = atomic_compare_and_exchange_val_acq(mem, newval, oldval);	\
+     /* Return 1 if it was already acquired */				\
+     (ret != oldval);							\
+   })
+#else
+/* Non-atomic primitives. */
+# define atomic_compare_and_exchange_val_acq(mem, newval, oldval) \
+  ({ __typeof (mem) __gmemp = (mem);				      \
+     __typeof (*mem) __gret = *__gmemp;				      \
+     __typeof (*mem) __gnewval = (newval);			      \
+								      \
+     if (__gret == (oldval))					      \
+       *__gmemp = __gnewval;					      \
+     __gret; })
+
+# define atomic_compare_and_exchange_bool_acq(mem, newval, oldval) \
+  ({ __typeof (mem) __gmemp = (mem);				      \
+     __typeof (*mem) __gnewval = (newval);			      \
+								      \
+     *__gmemp == (oldval) ? (*__gmemp = __gnewval, 0) : 1; })
+#endif
+
+#endif	/* bits/atomic.h */
+
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/bits/fcntl.h glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/bits/fcntl.h
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/bits/fcntl.h	2004-08-23 09:28:44.000000000 +0200
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/bits/fcntl.h	2006-08-06 09:40:21.000000000 +0200
@@ -23,7 +23,9 @@
 #endif
 
 #include <sys/types.h>
-
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
 
 /* open/fcntl - O_SYNC is only implemented on blocks devices and on files
    located on an ext2 file system */
@@ -44,10 +46,10 @@
 
 
 #ifdef __USE_GNU
-# define O_DIRECT	00040000 /* direct disk access hint - currently ignored */
-# define O_DIRECTORY	00010000 /* must be a directory */
-# define O_NOFOLLOW	00000200 /* don't follow links */
-# define O_NOATIME	04000000 /* Do not set atime.  */
+# define O_DIRECT	00040000 /* Direct disk access. */
+# define O_DIRECTORY	00010000 /* Must be a directory. */
+# define O_NOFOLLOW	00000200 /* Do not follow links. */
+# define O_NOATIME	04000000 /* Do not set atime. */
 #endif
 
 #ifdef __USE_LARGEFILE64
@@ -74,7 +76,6 @@
 # define F_SETLK	F_SETLK64 /* Set record locking info (non-blocking). */
 # define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
 #endif
-
 #define F_GETLK64	8	/* Get record locking info.  */
 #define F_SETLK64	9	/* Set record locking info (non-blocking).  */
 #define F_SETLKW64	10	/* Set record locking info (blocking).  */
@@ -172,10 +173,50 @@
 # define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
 #endif
 
+#ifdef __USE_GNU
+# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
+					     in the range before performing the
+					     write.  */
+# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
+					     dirty pages in the range which are
+					     not presently under writeback.  */
+# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
+					     the range after performing the
+					     write.  */
+
+/* Flags for SPLICE and VMSPLICE.  */
+# define SPLICE_F_MOVE		1	/* Move pages instead of copying.  */
+# define SPLICE_F_NONBLOCK	2	/* Don't block on the pipe splicing
+					   (but we may still block on the fd
+					   we splice from/to).  */
+# define SPLICE_F_MORE		4	/* Expect more data.  */
+# define SPLICE_F_GIFT		8	/* Pages passed in are a gift.  */
+#endif
+
 __BEGIN_DECLS
 
+#ifdef __USE_GNU
+
 /* Provide kernel hint to read ahead.  */
 extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
     __THROW;
 
+/* Selective file content synch'ing.  */
+extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
+			    unsigned int __flags);
+
+/* Splice address range into a pipe.  */
+extern int vmsplice (int __fdout, const struct iovec *__iov, size_t __count,
+		     unsigned int __flags);
+
+/* Splice two files together.  */
+extern int splice (int __fdin, int __fdout, size_t __len, unsigned int __flags)
+    __THROW;
+
+/* In-kernel implementation of tee for pipe buffers.  */
+extern int tee (int __fdin, int __fdout, size_t __len, unsigned int __flags)
+    __THROW;
+    
+#endif
+    
 __END_DECLS
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/bits/mman.h glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/bits/mman.h
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/bits/mman.h	2003-09-25 18:39:38.000000000 +0200
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/bits/mman.h	2006-05-24 17:31:25.000000000 +0200
@@ -53,14 +53,20 @@
 #define MCL_CURRENT	1		/* lock all current mappings */
 #define MCL_FUTURE	2		/* lock all future mappings */
 
-#define MADV_NORMAL     0               /* no further special treatment */
-#define MADV_RANDOM     1               /* expect random page references */
-#define MADV_SEQUENTIAL 2               /* expect sequential page references */
-#define MADV_WILLNEED   3               /* will need these pages */
-#define MADV_DONTNEED   4               /* dont need these pages */
-#define MADV_SPACEAVAIL 5               /* insure that resources are reserved */
-#define MADV_VPS_PURGE  6               /* Purge pages from VM page cache */
-#define MADV_VPS_INHERIT 7              /* Inherit parents page size */
+/* Advice to "madvise" */
+#ifdef __USE_BSD
+# define MADV_NORMAL	  0	/* no further special treatment */
+# define MADV_RANDOM	  1	/* expect random page references */
+# define MADV_SEQUENTIAL  2	/* expect sequential page references */
+# define MADV_WILLNEED	  3	/* will need these pages */
+# define MADV_DONTNEED	  4	/* dont need these pages */
+# define MADV_SPACEAVAIL  5	/* insure that resources are reserved */
+# define MADV_VPS_PURGE	  6	/* Purge pages from VM page cache */
+# define MADV_VPS_INHERIT 7	/* Inherit parents page size */
+# define MADV_REMOVE	  9	/* Remove these pages and resources.  */
+# define MADV_DONTFORK	 10	/* Do not inherit across fork.  */
+# define MADV_DOFORK	 11	/* Do inherit across fork.  */
+#endif
 
 /* The range 12-64 is reserved for page size specification. */
 #define MADV_4K_PAGES   12              /* Use 4K pages  */
@@ -80,4 +86,7 @@
 /* Flags for `mremap'.  */
 #ifdef __USE_GNU
 # define MREMAP_MAYMOVE 1
+# define MREMAP_FIXED	2
 #endif
+
+
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/clone.S glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/clone.S
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/clone.S	2005-05-26 16:30:47.000000000 +0200
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/clone.S	2006-05-24 17:33:28.000000000 +0200
@@ -26,35 +26,62 @@
 #define _ERRNO_H	1
 #include <bits/errno.h>
 
-/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg) */
+/* Non-thread code calls __clone with the following parameters:
+   int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg)
+   
+   NPTL Code will call __clone with the following parameters:
+   int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+	     int *parent_tidptr, struct user_desc *newtls, int *child_pidptr)
+	
+   The code should not mangle the extra input registers.
+   Syscall expects:				Input to __clone:
+	4(r25) - function pointer 		(r26, arg0) 
+	0(r25) - argument			(r23, arg3)
+	r26 - clone flags.			(r24, arg2)
+	r25+64 - user stack pointer.		(r25, arg1)
+	r24 - parent tid pointer.		(stack - 52)
+	r23 - struct user_desc newtls pointer.	(stack - 56)
+	r22 - child tid pointer.		(stack - 60)
+	r20 - clone syscall number		(constant)
+ */
 
         .text
 ENTRY(__clone)
-	/* FIXME: I have no idea how profiling works on hppa. */
 
 	/* Sanity check arguments.  */
-	comib,=  0,%arg0,.Lerror        /* no NULL function pointers */
 	ldi     -EINVAL,%ret0
-	comib,=  0,%arg1,.Lerror        /* no NULL stack pointers */
-	nop
+	comib,=,n  0,%arg0,.Lerror        /* no NULL function pointers */
+	comib,=,n  0,%arg1,.Lerror        /* no NULL stack pointers */
 
 	/* Save the fn ptr and arg on the new stack.  */
-	stwm    %arg0,64(%arg1)
-	stw	%arg3,-60(%arg1)
+	stwm    %r26,64(%r25)
+	stw	%r23,-60(%r25)
+	/* Clone arguments are (int flags, void * child_stack) */
+	copy	%r24,%r26	/* flags are first */
+	/* User stack pointer is in the correct register already */
+
+	/* Load args from stack... */
+	ldw	-52(%sp), %r24	/* Load parent_tidptr */
+	ldw	-56(%sp), %r23 	/* Load newtls */
+	ldw	-60(%sp), %r22	/* Load child_tidptr */
+
+	/* Create frame to get r3 free */
+	copy	%sp, %r21
+	stwm	%r3, 64(%sp)
+	stw	%r21, -4(%sp)
 
 	/* Save the PIC register. */
 #ifdef PIC
-	stw	%r19,-32(%sr0, %sp)	/* parent */
+	copy	%r19, %r3		/* parent */
 #endif
 
 	/* Do the system call */
-	copy	%arg2,%arg0
 	ble     0x100(%sr2,%r0)
 	ldi	__NR_clone,%r20
 
 	ldi	-4096,%r1
 	comclr,>>= %r1,%ret0,%r0	/* Note: unsigned compare. */
-	b,n	.Lerror
+	b,n	.LerrorRest
 
 	comib,=,n 0,%ret0,thread_start
 
@@ -63,18 +90,25 @@
 	   since we return immediately. */
 
 	bv	%r0(%rp)
-	nop
-
-	/* Something bad happened -- no child created */
-.Lerror:
+	ldwm	-64(%sp), %r3
 
+.LerrorRest:
 	/* Restore the PIC register on error */
 #ifdef PIC
-	ldw	-32(%sr0, %sp), %r19	/* parent */
+	copy	%r3, %r19		/* parent */ 
 #endif
 
+	/* Something bad happened -- no child created */
+.Lerror:
+
+	/* Set errno, save ret0 so we return with that value. */
+	copy	%ret0, %r3
 	b	__syscall_error
 	sub     %r0,%ret0,%arg0
+	copy	%r3, %ret0
+	/* Return after setting errno, and restoring ret0 */
+	bv	%r0(%rp)
+	ldwm	-64(%sp), %r3
 
 thread_start:
 
@@ -92,7 +126,7 @@
 	copy	%ret0,%arg0
 
 	/* Die horribly.  */
-	iitlbp	%r0,(%r0)
+	iitlbp	%r0,(%sr0,%r0)
 
 PSEUDO_END(__clone)
 
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/fxstatat.c glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/fxstatat.c
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/fxstatat.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/fxstatat.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fxstatat.c>
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/fxstat.c glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/fxstat.c
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/fxstat.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/fxstat.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/fxstat.c>
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/kernel-features.h glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/kernel-features.h
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/kernel-features.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/kernel-features.h	2006-08-06 09:40:20.000000000 +0200
@@ -0,0 +1,39 @@
+/* Set flags signalling availability of kernel features based on given
+   kernel version number.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* There are an infinite number of PA-RISC kernel versions numbered
+   2.4.0.  But they've not really been released as such.  We require
+   and expect the final version here.  */
+#define __ASSUME_32BITUIDS		1
+#define __ASSUME_TRUNCATE64_SYSCALL	1
+#define __ASSUME_MMAP2_SYSCALL		1
+#define __ASSUME_STAT64_SYSCALL		1
+#define __ASSUME_IPC64			1
+#define __ASSUME_ST_INO_64_BIT		1
+#define __ASSUME_FCNTL64		1
+#define __ASSUME_GETDENTS64_SYSCALL	1
+
+/* PA-RISC 2.6.9 kernels had the first LWS CAS support */
+#if __LINUX_KERNEL_VERSION >= 0x020609
+# define __ASSUME_LWS_CAS		1
+#endif
+
+#include_next <kernel-features.h>
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/aio_cancel.c glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/aio_cancel.c
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/aio_cancel.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/aio_cancel.c	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,33 @@
+#include <shlib-compat.h>
+
+#define aio_cancel64 XXX
+#include <aio.h>
+#undef aio_cancel64
+#include <errno.h>
+
+extern __typeof (aio_cancel) __new_aio_cancel;
+extern __typeof (aio_cancel) __old_aio_cancel;
+
+#define aio_cancel	__new_aio_cancel
+
+#include <sysdeps/pthread/aio_cancel.c>
+
+#undef aio_cancel
+strong_alias (__new_aio_cancel, __new_aio_cancel64);
+versioned_symbol (librt, __new_aio_cancel, aio_cancel, GLIBC_2_3);
+versioned_symbol (librt, __new_aio_cancel64, aio_cancel64, GLIBC_2_3);
+
+#if SHLIB_COMPAT (librt, GLIBC_2_1, GLIBC_2_3)
+
+#undef ECANCELED
+#define aio_cancel	__old_aio_cancel
+#define ECANCELED	125
+
+#include <sysdeps/pthread/aio_cancel.c>
+
+#undef aio_cancel
+strong_alias (__old_aio_cancel, __old_aio_cancel64);
+compat_symbol (librt, __old_aio_cancel, aio_cancel, GLIBC_2_1);
+compat_symbol (librt, __old_aio_cancel64, aio_cancel64, GLIBC_2_1);
+
+#endif
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/initspin.h glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/initspin.h
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/initspin.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/initspin.h	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,41 @@
+/* PA-RISC specific definitions for spinlock initializers.
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* Initial value of a spinlock.  PA-RISC only implements atomic load
+   and clear so this must be non-zero. */
+#define __LT_SPINLOCK_INIT ((__atomic_lock_t) { { 1, 1, 1, 1 } })
+
+/* Initialize global spinlocks without cast, generally macro wrapped */
+#define __LT_SPINLOCK_ALT_INIT { { 1, 1, 1, 1 } }
+
+/* Macros for lock initializers, not using the above definition.
+   The above definition is not used in the case that static initializers
+   use this value. */
+#define __LOCK_ALT_INITIALIZER { __LT_SPINLOCK_ALT_INIT, 0 }
+
+/* Used to initialize _pthread_fastlock's in non-static case */
+#define __LOCK_INITIALIZER ((struct _pthread_fastlock){ __LT_SPINLOCK_INIT, 0 })
+
+/* Used in pthread_atomic initialization */
+#define __ATOMIC_INITIALIZER { 0, __LT_SPINLOCK_ALT_INIT }
+
+/* Tell the rest of the code that the initializer is non-zero without
+   explaining it's internal structure */
+#define __LT_INITIALIZER_NOT_ZERO
+
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/pthreadtypes.h glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/pthreadtypes.h
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/pthreadtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/bits/pthreadtypes.h	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,160 @@
+/* Linuxthreads - a simple clone()-based implementation of Posix        */
+/* threads for Linux.                                                   */
+/* Copyright (C) 1996 Xavier Leroy (Xavier.Leroy@inria.fr)              */
+/*                                                                      */
+/* This program is free software; you can redistribute it and/or        */
+/* modify it under the terms of the GNU Library General Public License  */
+/* as published by the Free Software Foundation; either version 2       */
+/* of the License, or (at your option) any later version.               */
+/*                                                                      */
+/* This program is distributed in the hope that it will be useful,      */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of       */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        */
+/* GNU Library General Public License for more details.                 */
+
+#if !defined _BITS_TYPES_H && !defined _PTHREAD_H
+# error "Never include <bits/pthreadtypes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#define __need_schedparam
+#include <bits/sched.h>
+
+/* We need 128-bit alignment for the ldcw semaphore.  At most, we are
+   assured of 64-bit alignment for stack locals and malloc'd data.  Thus,
+   we use a struct with four ints for the atomic lock type.  The locking
+   code will figure out which of the four to use for the ldcw semaphore.  */
+typedef volatile struct {
+  int lock[4];
+} __attribute__ ((aligned(16))) __atomic_lock_t;
+
+/* Fast locks (not abstract because mutexes and conditions aren't abstract). */
+struct _pthread_fastlock
+{
+  __atomic_lock_t __spinlock;	/* Used by compare_and_swap emulation.  Also,
+				   adaptive SMP lock stores spin count here. */
+  long int __status;		/* "Free" or "taken" or head of waiting list */
+};
+
+#ifndef _PTHREAD_DESCR_DEFINED
+/* Thread descriptors */
+typedef struct _pthread_descr_struct *_pthread_descr;
+# define _PTHREAD_DESCR_DEFINED
+#endif
+
+
+/* Attributes for threads.  */
+typedef struct __pthread_attr_s
+{
+  int __detachstate;
+  int __schedpolicy;
+  struct __sched_param __schedparam;
+  int __inheritsched;
+  int __scope;
+  size_t __guardsize;
+  int __stackaddr_set;
+  void *__stackaddr;
+  size_t __stacksize;
+} pthread_attr_t;
+
+
+/* Conditions (not abstract because of PTHREAD_COND_INITIALIZER */
+
+#ifdef __GLIBC_HAVE_LONG_LONG
+__extension__ typedef long long __pthread_cond_align_t;
+#else
+typedef long __pthread_cond_align_t;
+#endif
+
+typedef struct
+{
+  struct _pthread_fastlock __c_lock; /* Protect against concurrent access */
+  _pthread_descr __c_waiting;        /* Threads waiting on this condition */
+  char __padding[48 - sizeof (struct _pthread_fastlock)
+		 - sizeof (_pthread_descr) - sizeof (__pthread_cond_align_t)];
+  __pthread_cond_align_t __align;
+} pthread_cond_t;
+
+
+/* Attribute for conditionally variables.  */
+typedef struct
+{
+  int __dummy;
+} pthread_condattr_t;
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Mutexes (not abstract because of PTHREAD_MUTEX_INITIALIZER).  */
+/* (The layout is unnatural to maintain binary compatibility
+    with earlier releases of LinuxThreads.) */
+typedef struct
+{
+  int __m_reserved;               /* Reserved for future use */
+  int __m_count;                  /* Depth of recursive locking */
+  _pthread_descr __m_owner;       /* Owner thread (if recursive or errcheck) */
+  int __m_kind;                   /* Mutex kind: fast, recursive or errcheck */
+  struct _pthread_fastlock __m_lock; /* Underlying fast lock */
+} pthread_mutex_t;
+
+
+/* Attribute for mutex.  */
+typedef struct
+{
+  int __mutexkind;
+} pthread_mutexattr_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#ifdef __USE_UNIX98
+/* Read-write locks.  */
+typedef struct _pthread_rwlock_t
+{
+  struct _pthread_fastlock __rw_lock; /* Lock to guarantee mutual exclusion */
+  int __rw_readers;                   /* Number of readers */
+  _pthread_descr __rw_writer;         /* Identity of writer, or NULL if none */
+  _pthread_descr __rw_read_waiting;   /* Threads waiting for reading */
+  _pthread_descr __rw_write_waiting;  /* Threads waiting for writing */
+  int __rw_kind;                      /* Reader/Writer preference selection */
+  int __rw_pshared;                   /* Shared between processes or not */
+} pthread_rwlock_t;
+
+
+/* Attribute for read-write locks.  */
+typedef struct
+{
+  int __lockkind;
+  int __pshared;
+} pthread_rwlockattr_t;
+#endif
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef __atomic_lock_t pthread_spinlock_t;
+
+/* POSIX barrier. */
+typedef struct {
+  struct _pthread_fastlock __ba_lock; /* Lock to guarantee mutual exclusion */
+  int __ba_required;                  /* Threads needed for completion */
+  int __ba_present;                   /* Threads waiting */
+  _pthread_descr __ba_waiting;        /* Queue of waiting threads */
+} pthread_barrier_t;
+
+/* barrier attribute */
+typedef struct {
+  int __pshared;
+} pthread_barrierattr_t;
+
+#endif
+
+
+/* Thread identifiers */
+typedef unsigned long int pthread_t;
+
+#endif	/* bits/pthreadtypes.h */
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/malloc-machine.h glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/malloc-machine.h
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/malloc-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/malloc-machine.h	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,73 @@
+/* HP-PARISC macro definitions for mutexes, thread-specific data 
+   and parameters for malloc.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@baldric.uwo.ca>, 2003.
+   
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MALLOC_MACHINE_H
+#define _MALLOC_MACHINE_H
+
+#undef thread_atfork_static
+
+#include <atomic.h>
+#include <bits/libc-lock.h>
+
+__libc_lock_define (typedef, mutex_t)
+
+/* Since our lock structure does not tolerate being initialized to zero, we must
+   modify the standard function calls made by malloc */
+#  define mutex_init(m)		\
+	__libc_maybe_call (__pthread_mutex_init, (m, NULL), \
+		(((m)->__m_lock.__spinlock = __LT_SPINLOCK_INIT),(*(int *)(m))) )
+#  define mutex_lock(m)		\
+	__libc_maybe_call (__pthread_mutex_lock, (m), \
+			(__load_and_clear(&((m)->__m_lock.__spinlock)), 0))
+#  define mutex_trylock(m)	\
+	__libc_maybe_call (__pthread_mutex_trylock, (m), \
+			(*(int *)(m) ? 1 : (__load_and_clear(&((m)->__m_lock.__spinlock)), 0)))
+#  define mutex_unlock(m)	\
+	__libc_maybe_call (__pthread_mutex_unlock, (m), \
+			(((m)->__m_lock.__spinlock = __LT_SPINLOCK_INIT), (*(int *)(m))) )
+	
+/* This is defined by newer gcc version unique for each module.  */
+extern void *__dso_handle __attribute__ ((__weak__));
+
+#include <fork.h>
+
+#ifdef SHARED
+# define thread_atfork(prepare, parent, child) \
+   __register_atfork (prepare, parent, child, __dso_handle)
+#else
+# define thread_atfork(prepare, parent, child) \
+   __register_atfork (prepare, parent, child,				      \
+		      &__dso_handle == NULL ? NULL : __dso_handle)
+#endif
+
+/* thread specific data for glibc */
+
+#include <bits/libc-tsd.h>
+
+typedef int tsd_key_t[1];	/* no key data structure, libc magic does it */
+__libc_tsd_define (static, MALLOC)	/* declaration/common definition */
+#define tsd_key_create(key, destr)	((void) (key))
+#define tsd_setspecific(key, data)	__libc_tsd_set (MALLOC, (data))
+#define tsd_getspecific(key, vptr)	((vptr) = __libc_tsd_get (MALLOC))
+
+#include <sysdeps/generic/malloc-machine.h>
+
+#endif /* !defined(_MALLOC_MACHINE_H) */
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/pt-initfini.c glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/pt-initfini.c
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/pt-initfini.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/pt-initfini.c	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,109 @@
+/* Special .init and .fini section support for HPPA.  Linuxthreads version.
+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it
+   and/or modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file.  (The Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   The GNU C Library is distributed in the hope that it will be
+   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
+   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* This file is compiled into assembly code which is then munged by a sed
+   script into two files: crti.s and crtn.s.
+
+   * crti.s puts a function prologue at the beginning of the
+   .init and .fini sections and defines global symbols for
+   those addresses, so they can be called as functions.
+
+   * crtn.s puts the corresponding function epilogues
+   in the .init and .fini sections. */
+
+/* If we use the standard C version, the linkage table pointer won't
+   be properly preserved due to the splitting up of function prologues
+   and epilogues.  Therefore we write these in assembly to make sure
+   they do the right thing.  */
+
+__asm__ (
+"#include \"defs.h\"\n"
+"\n"
+"/*@HEADER_ENDS*/\n"
+"\n"
+"/*@_init_PROLOG_BEGINS*/\n"
+"	.section .init\n"
+"	.align 4\n"
+"	.globl _init\n"
+"	.type _init,@function\n"
+"_init:\n"
+"	stw	%rp,-20(%sp)\n"
+"	stwm	%r4,64(%sp)\n"
+"	stw	%r19,-32(%sp)\n"
+"	bl	__pthread_initialize_minimal,%rp\n"
+"	copy	%r19,%r4	/* delay slot */\n"
+"	copy	%r4,%r19\n"
+"/*@_init_PROLOG_ENDS*/\n"
+"\n"
+"/*@_init_EPILOG_BEGINS*/\n"
+"/* Here is the tail end of _init.  */\n"
+"	.section .init\n"
+"	ldw	-84(%sp),%rp\n"
+"	copy	%r4,%r19\n"
+"	bv	%r0(%rp)\n"
+"_end_init:\n"
+"	ldwm	-64(%sp),%r4\n"
+"\n"
+"/* Our very own unwind info, because the assembler can't handle\n"
+"   functions split into two or more pieces.  */\n"
+"	.section .PARISC.unwind,\"a\",@progbits\n"
+"	.extern _init\n"
+"	.word	_init, _end_init\n"
+"	.byte	0x08, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08\n"
+"\n"
+"/*@_init_EPILOG_ENDS*/\n"
+"\n"
+"/*@_fini_PROLOG_BEGINS*/\n"
+"	.section .fini\n"
+"	.align 4\n"
+"	.globl _fini\n"
+"	.type _fini,@function\n"
+"_fini:\n"
+"	stw	%rp,-20(%sp)\n"
+"	stwm	%r4,64(%sp)\n"
+"	stw	%r19,-32(%sp)\n"
+"	copy	%r19,%r4\n"
+"/*@_fini_PROLOG_ENDS*/\n"
+"\n"
+"/*@_fini_EPILOG_BEGINS*/\n"
+"	.section .fini\n"
+"	ldw	-84(%sp),%rp\n"
+"	copy	%r4,%r19\n"
+"	bv	%r0(%rp)\n"
+"_end_fini:\n"
+"	ldwm	-64(%sp),%r4\n"
+"\n"
+"	.section .PARISC.unwind,\"a\",@progbits\n"
+"	.extern _fini\n"
+"	.word	_fini, _end_fini\n"
+"	.byte	0x08, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08\n"
+"\n"
+"/*@_fini_EPILOG_ENDS*/\n"
+"\n"
+"/*@TRAILER_BEGINS*/\n"
+);
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/sysdep-cancel.h glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/sysdep-cancel.h
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/sysdep-cancel.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/linuxthreads/sysdep-cancel.h	2006-04-19 07:35:34.000000000 +0200
@@ -0,0 +1,238 @@
+/* cancellable system calls for Linux/HPPA.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Carlos O'Donell <carlos@baldric.uwo.ca>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <linuxthreads/internals.h>
+#endif
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+# ifndef NO_ERROR
+#  define NO_ERROR -0x1000
+# endif
+
+/* The syscall cancellation mechanism requires userspace
+   assistance, the following code does roughly this:
+
+   	do arguments (read arg5 and arg6 to registers)
+	setup frame
+	
+	check if there are threads, yes jump to pseudo_cancel
+	
+	unthreaded:
+		syscall
+		check syscall return (jump to pre_end)
+		set errno
+		set return to -1
+		(jump to pre_end)
+		
+	pseudo_cancel:
+		cenable
+		syscall
+		cdisable
+		check syscall return (jump to pre_end)
+		set errno
+		set return to -1
+		
+	pre_end
+		restore stack
+	
+	It is expected that 'ret' and 'END' macros will
+	append an 'undo arguments' and 'return' to the 
+	this PSEUDO macro. */
+   
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				\
+	ENTRY (name)							\
+	DOARGS_##args					ASM_LINE_SEP	\
+	copy TREG, %r1					ASM_LINE_SEP	\
+	copy %sp, TREG					ASM_LINE_SEP	\
+	stwm %r1, 64(%sp)				ASM_LINE_SEP	\
+	stw %rp, -20(%sp)				ASM_LINE_SEP	\
+	stw TREG, -4(%sp)				ASM_LINE_SEP	\
+	/* Done setting up frame, continue... */	ASM_LINE_SEP	\
+	SINGLE_THREAD_P					ASM_LINE_SEP	\
+	cmpib,<>,n 0,%ret0,L(pseudo_cancel)		ASM_LINE_SEP	\
+L(unthreaded):						ASM_LINE_SEP	\
+	/* Save r19 */					ASM_LINE_SEP	\
+	SAVE_PIC(TREG)					ASM_LINE_SEP	\
+	/* Do syscall, delay loads # */			ASM_LINE_SEP	\
+	ble  0x100(%sr2,%r0)				ASM_LINE_SEP	\
+	ldi SYS_ify (syscall_name), %r20 /* delay */	ASM_LINE_SEP	\
+	ldi NO_ERROR,%r1				ASM_LINE_SEP	\
+	cmpb,>>=,n %r1,%ret0,L(pre_end)			ASM_LINE_SEP	\
+	/* Restore r19 from TREG */			ASM_LINE_SEP	\
+	LOAD_PIC(TREG) /* delay */			ASM_LINE_SEP	\
+	SYSCALL_ERROR_HANDLER				ASM_LINE_SEP	\
+	/* Use TREG for temp storage */			ASM_LINE_SEP	\
+	copy %ret0, TREG /* delay */			ASM_LINE_SEP	\
+	/* OPTIMIZE: Don't reload r19 */		ASM_LINE_SEP	\
+	/* do a -1*syscall_ret0 */			ASM_LINE_SEP	\
+	sub %r0, TREG, TREG				ASM_LINE_SEP	\
+	/* Store into errno location */			ASM_LINE_SEP	\
+	stw TREG, 0(%sr0,%ret0)				ASM_LINE_SEP	\
+	b L(pre_end)					ASM_LINE_SEP	\
+	/* return -1 as error */			ASM_LINE_SEP	\
+	ldo -1(%r0), %ret0 /* delay */			ASM_LINE_SEP	\
+L(pseudo_cancel):					ASM_LINE_SEP	\
+	PUSHARGS_##args /* Save args */			ASM_LINE_SEP	\
+	/* Save r19 into TREG */			ASM_LINE_SEP	\
+	CENABLE /* FUNC CALL */				ASM_LINE_SEP	\
+	SAVE_PIC(TREG) /* delay */			ASM_LINE_SEP	\
+	/* restore syscall args */			ASM_LINE_SEP	\
+	POPARGS_##args					ASM_LINE_SEP	\
+	/* save mask from cenable (use stub rp slot) */	ASM_LINE_SEP	\
+	stw %ret0, -24(%sp)				ASM_LINE_SEP	\
+	/* ... SYSCALL ... */				ASM_LINE_SEP	\
+	ble 0x100(%sr2,%r0)				ASM_LINE_SEP    \
+	ldi SYS_ify (syscall_name), %r20 /* delay */	ASM_LINE_SEP	\
+	/* ............... */				ASM_LINE_SEP	\
+	LOAD_PIC(TREG)					ASM_LINE_SEP	\
+	/* pass mask as arg0 to cdisable */		ASM_LINE_SEP	\
+	ldw -24(%sp), %r26				ASM_LINE_SEP	\
+	CDISABLE					ASM_LINE_SEP	\
+	stw %ret0, -24(%sp) /* delay */			ASM_LINE_SEP	\
+	/* Restore syscall return */			ASM_LINE_SEP	\
+	ldw -24(%sp), %ret0				ASM_LINE_SEP	\
+	/* compare error */				ASM_LINE_SEP	\
+	ldi NO_ERROR,%r1				ASM_LINE_SEP	\
+	/* branch if no error */			ASM_LINE_SEP	\
+	cmpb,>>=,n %r1,%ret0,L(pre_end)			ASM_LINE_SEP	\
+	LOAD_PIC(TREG)	/* cond. nullify */		ASM_LINE_SEP	\
+	copy %ret0, TREG /* save syscall return */	ASM_LINE_SEP	\
+	SYSCALL_ERROR_HANDLER				ASM_LINE_SEP	\
+	/* make syscall res value positive */		ASM_LINE_SEP	\
+	sub %r0, TREG, TREG	/* delay */		ASM_LINE_SEP	\
+	/* No need to LOAD_PIC */			ASM_LINE_SEP	\
+	/* store into errno location */			ASM_LINE_SEP	\
+	stw TREG, 0(%sr0,%ret0)				ASM_LINE_SEP	\
+	/* return -1 */					ASM_LINE_SEP	\
+	ldo -1(%r0), %ret0				ASM_LINE_SEP	\
+L(pre_end):						ASM_LINE_SEP	\
+	/* Restore rp before exit */			ASM_LINE_SEP	\
+	ldw -84(%sr0,%sp), %rp				ASM_LINE_SEP	\
+	/* Undo frame */				ASM_LINE_SEP	\
+	ldwm -64(%sp),TREG				ASM_LINE_SEP	\
+	/* No need to LOAD_PIC */			ASM_LINE_SEP
+
+/* Save arguments into our frame */
+# define PUSHARGS_0	/* nothing to do */
+# define PUSHARGS_1	PUSHARGS_0 stw %r26, -36(%sr0,%sp)	ASM_LINE_SEP
+# define PUSHARGS_2	PUSHARGS_1 stw %r25, -40(%sr0,%sp)	ASM_LINE_SEP
+# define PUSHARGS_3	PUSHARGS_2 stw %r24, -44(%sr0,%sp)	ASM_LINE_SEP
+# define PUSHARGS_4	PUSHARGS_3 stw %r23, -48(%sr0,%sp)	ASM_LINE_SEP
+# define PUSHARGS_5	PUSHARGS_4 stw %r22, -52(%sr0,%sp)	ASM_LINE_SEP 
+# define PUSHARGS_6	PUSHARGS_5 stw %r21, -56(%sr0,%sp)	ASM_LINE_SEP
+
+/* Bring them back from the stack */
+# define POPARGS_0	/* nothing to do */
+# define POPARGS_1	POPARGS_0 ldw -36(%sr0,%sp), %r26	ASM_LINE_SEP
+# define POPARGS_2	POPARGS_1 ldw -40(%sr0,%sp), %r25	ASM_LINE_SEP
+# define POPARGS_3	POPARGS_2 ldw -44(%sr0,%sp), %r24	ASM_LINE_SEP
+# define POPARGS_4	POPARGS_3 ldw -48(%sr0,%sp), %r23	ASM_LINE_SEP
+# define POPARGS_5	POPARGS_4 ldw -52(%sr0,%sp), %r22	ASM_LINE_SEP
+# define POPARGS_6	POPARGS_5 ldw -56(%sr0,%sp), %r21	ASM_LINE_SEP
+
+# ifdef IS_IN_libpthread
+#  ifdef PIC
+#   define CENABLE .import __pthread_enable_asynccancel,code ASM_LINE_SEP \
+			bl __pthread_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE .import __pthread_disable_asynccancel,code ASM_LINE_SEP \
+			bl __pthread_disable_asynccancel,%r2 ASM_LINE_SEP
+#  else
+#   define CENABLE .import __pthread_enable_asynccancel,code ASM_LINE_SEP \
+			bl __pthread_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE .import __pthread_disable_asynccancel,code ASM_LINE_SEP \
+			bl __pthread_disable_asynccancel,%r2 ASM_LINE_SEP
+#  endif
+# elif !defined NOT_IN_libc
+#  ifdef PIC
+#   define CENABLE .import __libc_enable_asynccancel,code ASM_LINE_SEP \
+			bl __libc_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE	.import __libc_disable_asynccancel,code ASM_LINE_SEP \
+			bl __libc_disable_asynccancel,%r2 ASM_LINE_SEP
+#  else
+#   define CENABLE .import __libc_enable_asynccancel,code ASM_LINE_SEP \
+			bl __libc_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE	.import __libc_disable_asynccancel,code ASM_LINE_SEP \
+			bl __libc_disable_asynccancel,%r2 ASM_LINE_SEP
+#  endif
+# else
+#  ifdef PIC
+#   define CENABLE .import __librt_enable_asynccancel,code ASM_LINE_SEP \
+			bl __librt_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE .import __librt_disable_asynccancel,code ASM_LINE_SEP \
+			bl __librt_disable_asynccancel,%r2 ASM_LINE_SEP
+#  else
+#   define CENABLE .import __librt_enable_asynccancel,code ASM_LINE_SEP \
+			bl __librt_enable_asynccancel,%r2 ASM_LINE_SEP
+#   define CDISABLE .import __librt_disable_asynccancel,code ASM_LINE_SEP \
+			bl __librt_disable_asynccancel,%r2 ASM_LINE_SEP
+#  endif
+# endif
+
+/* p_header.multiple_threads is +12 from the pthread_descr struct start,
+   We could have called __get_cr27() but we really want less overhead */
+# define MULTIPLE_THREADS_OFFSET 0xC
+
+/* cr27 has been initialized to 0x0 by kernel */
+# define NO_THREAD_CR27 0x0
+
+# ifdef IS_IN_libpthread
+#  define __local_multiple_threads __pthread_multiple_threads
+# elif !defined NOT_IN_libc
+#  define __local_multiple_threads __libc_multiple_threads
+# else
+#  define __local_multiple_threads __librt_multiple_threads
+# endif
+
+# ifndef __ASSEMBLER__
+ extern int __local_multiple_threads attribute_hidden;
+#  define SINGLE_THREAD_P __builtin_expect (__local_multiple_threads == 0, 1)
+# else
+/* This ALT version requires newer kernel support */
+#  define SINGLE_THREAD_P_MFCTL						\
+	mfctl %cr27, %ret0					ASM_LINE_SEP	\
+	cmpib,= NO_THREAD_CR27,%ret0,L(stp)			ASM_LINE_SEP	\
+	nop							ASM_LINE_SEP	\
+	ldw MULTIPLE_THREADS_OFFSET(%sr0,%ret0),%ret0		ASM_LINE_SEP	\
+L(stp):								ASM_LINE_SEP
+#  ifdef PIC
+/* Slower version uses GOT to get value of __local_multiple_threads */
+#   define SINGLE_THREAD_P							\
+	addil LT%__local_multiple_threads, %r19			ASM_LINE_SEP	\
+	ldw RT%__local_multiple_threads(%sr0,%r1), %ret0	ASM_LINE_SEP	\
+	ldw 0(%sr0,%ret0), %ret0 				ASM_LINE_SEP
+#  else
+/* Slow non-pic version using DP */
+#   define SINGLE_THREAD_P								\
+	addil LR%__local_multiple_threads-$global$,%r27  		ASM_LINE_SEP	\
+	ldw RR%__local_multiple_threads-$global$(%sr0,%r1),%ret0	ASM_LINE_SEP
+#  endif
+# endif
+#elif !defined __ASSEMBLER__
+
+/* This code should never be used but we define it anyhow.  */
+# define SINGLE_THREAD_P (1)
+
+#endif
+/* !defined NOT_IN_libc || defined IS_IN_libpthread */
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/lxstat.c glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/lxstat.c
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/lxstat.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/lxstat.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/lxstat.c>
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/sysdep.c glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/sysdep.c
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/sysdep.c	2003-10-15 07:45:16.000000000 +0200
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/sysdep.c	2006-05-15 02:44:14.000000000 +0200
@@ -16,12 +16,12 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <stdarg.h>
 #include <sysdep.h>
 #include <errno.h>
 
 extern int __syscall_error(int err_no);
-extern int syscall (int sysnum, int arg0, int arg1, int arg2,
-		    int arg3, int arg4, int arg5);
+extern long int syscall (long int __sysno, ...) __THROW;
 
 /* This routine is jumped to by all the syscall handlers, to stash
    an error number into errno.  */
@@ -37,22 +37,35 @@
    typically be in syscall.S. Also note that we have INLINE_SYSCALL,
    INTERNAL_SYSCALL, and all the generated pure assembly syscall wrappers.
    How often the function is used is unknown. */
-int
-syscall (int sysnum, int arg0, int arg1, int arg2, int arg3, int arg4,
-	 int arg5)
+
+long int 
+syscall (long int __sysno, ...) 
 {
   /* FIXME: Keep this matching INLINE_SYSCALL for hppa */
+  va_list args;
+  long int arg0, arg1, arg2, arg3, arg4, arg5;
   long int __sys_res;
+
+  /* Load varargs */
+  va_start (args, __sysno);
+  arg0 = va_arg (args, long int);
+  arg1 = va_arg (args, long int);
+  arg2 = va_arg (args, long int);
+  arg3 = va_arg (args, long int);
+  arg4 = va_arg (args, long int);
+  arg5 = va_arg (args, long int);
+  va_end (args);
+  
   {
     register unsigned long int __res asm("r28");
     LOAD_ARGS_6 (arg0, arg1, arg2, arg3, arg4, arg5)
-    asm volatile (STW_ASM_PIC
+    asm volatile (SAVE_ASM_PIC
 		  "	ble  0x100(%%sr2, %%r0)	\n"
 		  "	copy %1, %%r20		\n"
-		  LDW_ASM_PIC
+		  LOAD_ASM_PIC
 		  : "=r" (__res)
-		  : "r" (sysnum) ASM_ARGS_6
-		  : CALL_CLOB_REGS CLOB_ARGS_6);
+		  : "r" (__sysno) ASM_ARGS_6
+		  : "memory", CALL_CLOB_REGS CLOB_ARGS_6);
     __sys_res = __res;
   }
   if ((unsigned long int) __sys_res >= (unsigned long int) -4095)
@@ -62,3 +75,4 @@
     }
   return __sys_res;
 }
+
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/sysdep.h glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/sysdep.h
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/sysdep.h	2003-11-03 18:18:38.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/sysdep.h	2006-05-15 02:44:14.000000000 +0200
@@ -22,28 +22,34 @@
 #include <asm/unistd.h>
 #include <sysdeps/generic/sysdep.h>
 #include <sys/syscall.h>
-#include "config.h"
 
-#ifndef ASM_LINE_SEP
-# define ASM_LINE_SEP ;
-#endif
+#undef ASM_LINE_SEP
+#define ASM_LINE_SEP ! 
 
 #undef SYS_ify
 #define SYS_ify(syscall_name)	(__NR_##syscall_name)
 
+/* WARNING: TREG must be a callee saves register so 
+   that it doesn't have to be restored after a call 
+   to another function */
 #ifdef PIC
-/* WARNING: CANNOT BE USED IN A NOP! */
-# define STW_PIC stw %r19, -32(%sr0, %sp) ASM_LINE_SEP
-# define LDW_PIC ldw -32(%sr0, %sp), %r19 ASM_LINE_SEP
-# define STW_ASM_PIC	"       copy %%r19, %%r4\n"
-# define LDW_ASM_PIC	"       copy %%r4, %%r19\n"
-# define USING_GR4	"%r4",
+# define TREG %r3
+# define SAVE_PIC(SREG) copy %r19, SREG ASM_LINE_SEP
+# define LOAD_PIC(LREG) copy LREG, %r19 ASM_LINE_SEP
+/* Inline assembly defines */
+# define TREG_ASM "%r4" /* Cant clobber r3, it holds framemarker */
+# define SAVE_ASM_PIC	"       copy %%r19, %" TREG_ASM "\n"
+# define LOAD_ASM_PIC	"       copy %" TREG_ASM ", %%r19\n"
+# define USING_TREG	TREG_ASM,
 #else
-# define STW_PIC ASM_LINE_SEP
-# define LDW_PIC ASM_LINE_SEP
-# define STW_ASM_PIC	" \n"
-# define LDW_ASM_PIC	" \n"
-# define USING_GR4
+# define TREG %r3
+# define SAVE_PIC(SREG) nop ASM_LINE_SEP
+# define LOAD_PIC(LREG) nop ASM_LINE_SEP
+/* Inline assembly defines */
+# define TREG_ASM 
+# define SAVE_ASM_PIC	"nop \n"
+# define LOAD_ASM_PIC	"nop \n"
+# define USING_TREG
 #endif
 
 #ifdef __ASSEMBLER__
@@ -76,31 +82,73 @@
 
 /* We don't want the label for the error handle to be global when we define
    it here.  */
-#ifdef PIC
+/*#ifdef PIC
 # define SYSCALL_ERROR_LABEL 0f
 #else
 # define SYSCALL_ERROR_LABEL syscall_error
-#endif
+#endif*/
+
+/* Argument manipulation from the stack for preparing to
+   make a syscall */
+
+#define DOARGS_0 /* nothing */
+#define DOARGS_1 /* nothing */
+#define DOARGS_2 /* nothing */
+#define DOARGS_3 /* nothing */
+#define DOARGS_4 /* nothing */
+#define DOARGS_5 ldw -52(%sp), %r22		ASM_LINE_SEP
+#define DOARGS_6 DOARGS_5 ldw -56(%sp), %r21	ASM_LINE_SEP
+
+#define UNDOARGS_0 /* nothing */
+#define UNDOARGS_1 /* nothing */
+#define UNDOARGS_2 /* nothing */
+#define UNDOARGS_3 /* nothing */
+#define UNDOARGS_4 /* nothing */
+#define UNDOARGS_5 /* nothing */
+#define UNDOARGS_6 /* nothing */
 
 /* Define an entry point visible from C.
 
    There is currently a bug in gdb which prevents us from specifying
    incomplete stabs information.  Fake some entries here which specify
    the current source file.  */
-#define	ENTRY(name)						\
-	.text					ASM_LINE_SEP	\
-	.export C_SYMBOL_NAME(name)		ASM_LINE_SEP	\
-	.type	C_SYMBOL_NAME(name),@function	ASM_LINE_SEP	\
-	C_LABEL(name)				ASM_LINE_SEP	\
-	CALL_MCOUNT				ASM_LINE_SEP
+#define	ENTRY(name)							\
+	.text						ASM_LINE_SEP	\
+	.align ALIGNARG(4)				ASM_LINE_SEP	\
+	.export C_SYMBOL_NAME(name)			ASM_LINE_SEP	\
+	.type	C_SYMBOL_NAME(name),@function		ASM_LINE_SEP	\
+	C_LABEL(name)					ASM_LINE_SEP	\
+	.PROC						ASM_LINE_SEP	\
+	.CALLINFO FRAME=64,CALLS,SAVE_RP,ENTRY_GR=3	ASM_LINE_SEP	\
+	.ENTRY						ASM_LINE_SEP	\
+	/* SAVE_RP says we do */			ASM_LINE_SEP	\
+	stw %rp, -20(%sr0,%sp)				ASM_LINE_SEP	\
+	/*FIXME: Call mcount? (carefull with stack!) */
+
+/* Some syscall wrappers do not call other functions, and
+   hence are classified as leaf, so add NO_CALLS for gdb */
+#define	ENTRY_LEAF(name)						\
+	.text						ASM_LINE_SEP	\
+	.align ALIGNARG(4)				ASM_LINE_SEP	\
+	.export C_SYMBOL_NAME(name)			ASM_LINE_SEP	\
+	.type	C_SYMBOL_NAME(name),@function		ASM_LINE_SEP	\
+	C_LABEL(name)					ASM_LINE_SEP	\
+	.PROC						ASM_LINE_SEP	\
+	.CALLINFO FRAME=64,NO_CALLS,SAVE_RP,ENTRY_GR=3	ASM_LINE_SEP	\
+	.ENTRY						ASM_LINE_SEP	\
+	/* SAVE_RP says we do */			ASM_LINE_SEP	\
+	stw %rp, -20(%sr0,%sp)				ASM_LINE_SEP	\
+	/*FIXME: Call mcount? (carefull with stack!) */
 
 #undef	END
 #define END(name)							\
-1:							ASM_LINE_SEP	\
-.size	C_SYMBOL_NAME(name),1b-C_SYMBOL_NAME(name)	ASM_LINE_SEP
+  	.EXIT						ASM_LINE_SEP	\
+	.PROCEND					ASM_LINE_SEP	\
+.size	C_SYMBOL_NAME(name), .-C_SYMBOL_NAME(name)	ASM_LINE_SEP
 
-/* If compiled for profiling, call `mcount' at the start of each function.  */
-/* No, don't bother.  gcc will put the call in for us.  */
+/* If compiled for profiling, call `mcount' at the start 
+   of each function. No, don't bother.  gcc will put the 
+   call in for us.  */
 #define CALL_MCOUNT		/* Do nothing.  */
 
 /* syscall wrappers consist of
@@ -118,14 +166,16 @@
 */
 
 #define	PSEUDO(name, syscall_name, args)			\
-  ENTRY (name)							\
-  DO_CALL(syscall_name, args)			ASM_LINE_SEP	\
+  ENTRY (name)					ASM_LINE_SEP	\
+  /* If necc. load args from stack */		ASM_LINE_SEP	\
+  DOARGS_##args					ASM_LINE_SEP	\
+  DO_CALL (syscall_name, args)			ASM_LINE_SEP	\
+  UNDOARGS_##args				ASM_LINE_SEP	\
   nop						ASM_LINE_SEP
 
 #define ret \
-	/* Return value set by ERRNO code */	ASM_LINE_SEP	\
-	bv 0(2)					ASM_LINE_SEP	\
-	nop					ASM_LINE_SEP
+  /* Return value set by ERRNO code */		ASM_LINE_SEP	\
+  bv,n 0(2)					ASM_LINE_SEP
 
 #undef	PSEUDO_END
 #define	PSEUDO_END(name)					\
@@ -133,8 +183,10 @@
 
 /* We don't set the errno on the return from the syscall */
 #define	PSEUDO_NOERRNO(name, syscall_name, args)		\
-  ENTRY (name)							\
-  DO_CALL_NOERRNO(syscall_name, args)		ASM_LINE_SEP	\
+  ENTRY_LEAF (name)				ASM_LINE_SEP	\
+  DOARGS_##args					ASM_LINE_SEP	\
+  DO_CALL_NOERRNO (syscall_name, args)		ASM_LINE_SEP	\
+  UNDOARGS_##args				ASM_LINE_SEP	\
   nop						ASM_LINE_SEP
 
 #define ret_NOERRNO ret
@@ -146,9 +198,11 @@
 /* This has to return the error value */
 #undef  PSEUDO_ERRVAL
 #define PSEUDO_ERRVAL(name, syscall_name, args)			\
-	ENTRY(name)						\
-	DO_CALL_ERRVAL(syscall_name, args)	ASM_LINE_SEP	\
-	nop					ASM_LINE_SEP
+  ENTRY_LEAF (name)				ASM_LINE_SEP	\
+  DOARGS_##args					ASM_LINE_SEP	\
+  DO_CALL_ERRVAL (syscall_name, args)		ASM_LINE_SEP	\
+  UNDOARGS_##args				ASM_LINE_SEP	\
+  nop						ASM_LINE_SEP
 
 #define ret_ERRVAL ret
 
@@ -161,7 +215,8 @@
 #define SYSCALL_PIC_SETUP	/* Nothing.  */
 
 
-/* All the syscall assembly macros rely on finding the approriate
+/* FIXME: This comment is not true.
+ * All the syscall assembly macros rely on finding the approriate
    SYSCALL_ERROR_LABEL or rather HANDLER. */
 
 /* int * __errno_location(void) so you have to store your value
@@ -209,8 +264,8 @@
 	arg 2		gr25
 	arg 3		gr24
 	arg 4		gr23
-	arg 5		-52(gr30)
-	arg 6		-56(gr30)
+	arg 5		-52(sp)
+	arg 6		-56(sp)
 
    gr22 and gr21 are caller-saves, so we can just load the arguments
    there and generally be happy. */
@@ -219,46 +274,48 @@
  * is intended to mimic the if (__sys_res...)
  * code inside INLINE_SYSCALL
  */
+#define NO_ERROR -0x1000
 
 #undef	DO_CALL
 #define DO_CALL(syscall_name, args)				\
-	DOARGS_##args				ASM_LINE_SEP	\
-	STW_PIC					ASM_LINE_SEP	\
+  	copy TREG,%r1				ASM_LINE_SEP	\
+	copy %sp,TREG				ASM_LINE_SEP	\
+	/* Create a frame */			ASM_LINE_SEP	\
+	stwm %r1, 64(%sp)			ASM_LINE_SEP	\
+	stw %rp, -20(%sp)			ASM_LINE_SEP	\
+	stw TREG, -4(%sp)			ASM_LINE_SEP	\
+	/* Save r19 */				ASM_LINE_SEP	\
+	SAVE_PIC(TREG)				ASM_LINE_SEP	\
 	/* Do syscall, delay loads # */		ASM_LINE_SEP	\
 	ble  0x100(%sr2,%r0)			ASM_LINE_SEP	\
 	ldi SYS_ify (syscall_name), %r20	ASM_LINE_SEP	\
-	ldi -0x1000,%r1				ASM_LINE_SEP	\
-	cmpb,>>=,n %r1,%ret0,0f			ASM_LINE_SEP	\
-	/* save rp or we get lost */		ASM_LINE_SEP	\
-	stw %rp, -20(%sr0,%sp)			ASM_LINE_SEP	\
-	/* Restore r19 from frame */		ASM_LINE_SEP	\
-	LDW_PIC					ASM_LINE_SEP	\
-	stw %ret0, -24(%sr0,%sp)		ASM_LINE_SEP	\
+	ldi NO_ERROR,%r1			ASM_LINE_SEP	\
+	cmpb,>>=,n %r1,%ret0,L(pre_end)		ASM_LINE_SEP	\
+	/* Restore r19 from TREG */		ASM_LINE_SEP	\
+	LOAD_PIC(TREG) /* delay */		ASM_LINE_SEP	\
 	SYSCALL_ERROR_HANDLER			ASM_LINE_SEP	\
-	/* create frame */			ASM_LINE_SEP	\
-	ldo 64(%sp), %sp			ASM_LINE_SEP	\
-	ldo -64(%sp), %sp			ASM_LINE_SEP	\
+	/* Use TREG for temp storage */		ASM_LINE_SEP	\
+	copy %ret0, TREG /* delay */		ASM_LINE_SEP	\
 	/* OPTIMIZE: Don't reload r19 */	ASM_LINE_SEP	\
 	/* do a -1*syscall_ret0 */		ASM_LINE_SEP	\
-	ldw -24(%sr0,%sp), %r26			ASM_LINE_SEP	\
-	sub %r0, %r26, %r26			ASM_LINE_SEP	\
+	sub %r0, TREG, TREG			ASM_LINE_SEP	\
 	/* Store into errno location */		ASM_LINE_SEP	\
-	stw %r26, 0(%sr0,%ret0)			ASM_LINE_SEP	\
+	stw TREG, 0(%sr0,%ret0)			ASM_LINE_SEP	\
 	/* return -1 as error */		ASM_LINE_SEP	\
 	ldo -1(%r0), %ret0			ASM_LINE_SEP	\
-	ldw -20(%sr0,%sp), %rp			ASM_LINE_SEP	\
-0:						ASM_LINE_SEP	\
-	UNDOARGS_##args				ASM_LINE_SEP
+L(pre_end):					ASM_LINE_SEP	\
+	/* Restore return pointer */		ASM_LINE_SEP	\
+	ldw -84(%sp),%rp			ASM_LINE_SEP	\
+	/* Restore our frame, restoring TREG */	ASM_LINE_SEP	\
+	ldwm -64(%sp), TREG			ASM_LINE_SEP
 
 /* We do nothing with the return, except hand it back to someone else */
 #undef  DO_CALL_NOERRNO
 #define DO_CALL_NOERRNO(syscall_name, args)			\
-	DOARGS_##args                                           \
 	/* No need to store r19 */		ASM_LINE_SEP	\
 	ble  0x100(%sr2,%r0)                    ASM_LINE_SEP    \
 	ldi SYS_ify (syscall_name), %r20        ASM_LINE_SEP    \
-	/* Caller will restore r19 */		ASM_LINE_SEP	\
-	UNDOARGS_##args
+	/* Caller will restore r19 */		ASM_LINE_SEP
 
 /* Here, we return the ERRVAL in assembly, note we don't call the
    error handler function, but we do 'negate' the return _IF_
@@ -266,34 +323,15 @@
 
 #undef	DO_CALL_ERRVAL
 #define DO_CALL_ERRVAL(syscall_name, args)			\
-	DOARGS_##args				ASM_LINE_SEP	\
 	/* No need to store r19 */		ASM_LINE_SEP	\
 	ble  0x100(%sr2,%r0)			ASM_LINE_SEP	\
 	ldi SYS_ify (syscall_name), %r20	ASM_LINE_SEP	\
 	/* Caller will restore r19 */		ASM_LINE_SEP	\
-	ldi -0x1000,%r1				ASM_LINE_SEP	\
+	ldi NO_ERROR,%r1			ASM_LINE_SEP	\
 	cmpb,>>=,n %r1,%ret0,0f			ASM_LINE_SEP	\
 	sub %r0, %ret0, %ret0			ASM_LINE_SEP	\
-0:						ASM_LINE_SEP	\
-	UNDOARGS_##args				ASM_LINE_SEP
-
-#define DOARGS_0 /* nothing */
-#define DOARGS_1 /* nothing */
-#define DOARGS_2 /* nothing */
-#define DOARGS_3 /* nothing */
-#define DOARGS_4 /* nothing */
-#define DOARGS_5 ldw -52(%r30), %r22		ASM_LINE_SEP
-#define DOARGS_6 ldw -52(%r30), %r22		ASM_LINE_SEP	\
-		 ldw -56(%r30), %r21		ASM_LINE_SEP
-
+0:						ASM_LINE_SEP
 
-#define UNDOARGS_0 /* nothing */
-#define UNDOARGS_1 /* nothing */
-#define UNDOARGS_2 /* nothing */
-#define UNDOARGS_3 /* nothing */
-#define UNDOARGS_4 /* nothing */
-#define UNDOARGS_5 /* nothing */
-#define UNDOARGS_6 /* nothing */
 
 #else
 
@@ -305,27 +343,28 @@
    registers r20 -> r26 will conflict with the list so they
    are treated specially. Although r19 is clobbered by the syscall
    we cannot say this because it would violate ABI, thus we say
-   r4 is clobbered and use that register to save/restore r19
+   TREG is clobbered and use that register to save/restore r19
    across the syscall. */
 
-#define CALL_CLOB_REGS	"%r1", "%r2", USING_GR4 \
+#define CALL_CLOB_REGS	"%r1", "%r2", USING_TREG \
 		 	"%r20", "%r29", "%r31"
 
 #undef INLINE_SYSCALL
-#define INLINE_SYSCALL(name, nr, args...)	({			\
+#define INLINE_SYSCALL(name, nr, args...)				\
+({									\
 	long __sys_res;							\
 	{								\
 		register unsigned long __res asm("r28");		\
 		LOAD_ARGS_##nr(args)					\
-		/* FIXME: HACK stw/ldw r19 around syscall */		\
+		/* FIXME: HACK save/load r19 around syscall */		\
 		asm volatile(						\
-			STW_ASM_PIC					\
+			SAVE_ASM_PIC					\
 			"	ble  0x100(%%sr2, %%r0)\n"		\
 			"	ldi %1, %%r20\n"			\
-			LDW_ASM_PIC					\
+			LOAD_ASM_PIC					\
 			: "=r" (__res)					\
 			: "i" (SYS_ify(name)) ASM_ARGS_##nr		\
-			: CALL_CLOB_REGS CLOB_ARGS_##nr			\
+			: "memory", CALL_CLOB_REGS CLOB_ARGS_##nr	\
 		);							\
 		__sys_res = (long)__res;				\
 	}								\
@@ -339,13 +378,13 @@
 /* INTERNAL_SYSCALL_DECL - Allows us to setup some function static
    value to use within the context of the syscall
    INTERNAL_SYSCALL_ERROR_P - Returns 0 if it wasn't an error, 1 otherwise
-   You are allowed to use the syscall result (val) and the DECL error variable
-   to determine what went wrong.
+   You are allowed to use the syscall result (val) and the DECL error 
+   variable to determine what went wrong.
    INTERLAL_SYSCALL_ERRNO - Munges the val/err pair into the error number.
    In our case we just flip the sign. */
 
 #undef INTERNAL_SYSCALL_DECL
-#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+#define INTERNAL_SYSCALL_DECL(err) 
 
 /* Equivalent to  (val < 0)&&(val > -4095) which is what we want */
 #undef INTERNAL_SYSCALL_ERROR_P
@@ -357,46 +396,72 @@
 
 /* Similar to INLINE_SYSCALL but we don't set errno */
 #undef INTERNAL_SYSCALL
-#define INTERNAL_SYSCALL(name, err, nr, args...) 		\
-({								\
-	long __sys_res;						\
-	{							\
-		register unsigned long __res asm("r28");	\
-		LOAD_ARGS_##nr(args)				\
-		/* FIXME: HACK stw/ldw r19 around syscall */	\
-		asm volatile(					\
-			STW_ASM_PIC				\
-			"	ble  0x100(%%sr2, %%r0)\n"	\
-			"	ldi %1, %%r20\n"		\
-			LDW_ASM_PIC				\
-			: "=r" (__res)				\
-			: "i" (SYS_ify(name)) ASM_ARGS_##nr	\
-			: CALL_CLOB_REGS CLOB_ARGS_##nr		\
-		);						\
-		__sys_res = (long)__res;			\
-	}							\
-	__sys_res;						\
+#define INTERNAL_SYSCALL(name, err, nr, args...) 			\
+({									\
+	long __sys_res;							\
+	{								\
+		register unsigned long __res asm("r28");		\
+		LOAD_ARGS_##nr(args)					\
+		/* FIXME: HACK save/load r19 around syscall */		\
+		asm volatile(						\
+			SAVE_ASM_PIC					\
+			"	ble  0x100(%%sr2, %%r0)\n"		\
+			"	ldi %1, %%r20\n"			\
+			LOAD_ASM_PIC					\
+			: "=r" (__res)					\
+			: "i" (SYS_ify(name)) ASM_ARGS_##nr		\
+			: "memory", CALL_CLOB_REGS CLOB_ARGS_##nr	\
+		);							\
+		__sys_res = (long)__res;				\
+	}								\
+	__sys_res;							\
+ })
+
+
+/* The _NCS variant allows non-constant syscall numbers.  */
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(name, err, nr, args...) 			\
+({									\
+	long __sys_res;							\
+	{								\
+		register unsigned long __res asm("r28");		\
+		LOAD_ARGS_##nr(args)					\
+		/* FIXME: HACK save/load r19 around syscall */		\
+		asm volatile(						\
+			SAVE_ASM_PIC					\
+			"	ble  0x100(%%sr2, %%r0)\n"		\
+			"	copy %1, %%r20\n"			\
+			LOAD_ASM_PIC					\
+			: "=r" (__res)					\
+			: "r" (name) ASM_ARGS_##nr			\
+			: "memory", CALL_CLOB_REGS CLOB_ARGS_##nr	\
+		);							\
+		__sys_res = (long)__res;				\
+	}								\
+	__sys_res;							\
  })
 
+
+
 #define LOAD_ARGS_0()
-#define LOAD_ARGS_1(r26)					\
-	register unsigned long __r26 __asm__("r26") = (unsigned long)(r26);   \
-	LOAD_ARGS_0()
-#define LOAD_ARGS_2(r26,r25)					\
-	register unsigned long __r25 __asm__("r25") = (unsigned long)(r25);   \
-	LOAD_ARGS_1(r26)
-#define LOAD_ARGS_3(r26,r25,r24)				\
-	register unsigned long __r24 __asm__("r24") = (unsigned long)(r24);   \
-	LOAD_ARGS_2(r26,r25)
-#define LOAD_ARGS_4(r26,r25,r24,r23)				\
-	register unsigned long __r23 __asm__("r23") = (unsigned long)(r23);   \
-	LOAD_ARGS_3(r26,r25,r24)
-#define LOAD_ARGS_5(r26,r25,r24,r23,r22)			\
-	register unsigned long __r22 __asm__("r22") = (unsigned long)(r22);   \
-	LOAD_ARGS_4(r26,r25,r24,r23)
-#define LOAD_ARGS_6(r26,r25,r24,r23,r22,r21)			\
-	register unsigned long __r21 __asm__("r21") = (unsigned long)(r21);   \
-	LOAD_ARGS_5(r26,r25,r24,r23,r22)
+#define LOAD_ARGS_1(r26)						\
+  register unsigned long __r26 __asm__("r26") = (unsigned long)(r26);	\
+  LOAD_ARGS_0()
+#define LOAD_ARGS_2(r26,r25)						\
+  register unsigned long __r25 __asm__("r25") = (unsigned long)(r25);	\
+  LOAD_ARGS_1(r26)
+#define LOAD_ARGS_3(r26,r25,r24)					\
+  register unsigned long __r24 __asm__("r24") = (unsigned long)(r24);	\
+  LOAD_ARGS_2(r26,r25)
+#define LOAD_ARGS_4(r26,r25,r24,r23)					\
+  register unsigned long __r23 __asm__("r23") = (unsigned long)(r23);	\
+  LOAD_ARGS_3(r26,r25,r24)
+#define LOAD_ARGS_5(r26,r25,r24,r23,r22)				\
+  register unsigned long __r22 __asm__("r22") = (unsigned long)(r22);	\
+  LOAD_ARGS_4(r26,r25,r24,r23)
+#define LOAD_ARGS_6(r26,r25,r24,r23,r22,r21)				\
+  register unsigned long __r21 __asm__("r21") = (unsigned long)(r21);	\
+  LOAD_ARGS_5(r26,r25,r24,r23,r22)
 
 /* Even with zero args we use r20 for the syscall number */
 #define ASM_ARGS_0
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/Versions glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/Versions
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/Versions	2002-08-29 01:55:01.000000000 +0200
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/Versions	2006-08-06 09:40:20.000000000 +0200
@@ -16,6 +16,9 @@
     #errlist-compat	254
     _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
   }
+  GLIBC_2.4 {
+    #errlist-compat	256
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
 }
 librt {
   GLIBC_2.3 {
diff -Nurd glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/xstat.c glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/xstat.c
--- glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/xstat.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-2.4/ports/sysdeps/unix/sysv/linux/hppa/xstat.c	2006-07-14 15:51:24.000000000 +0200
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/xstat.c>
