2009-05-23  Aurelien Jarno  <aurelien@aurel32.net>

	* elf/dl-misc.c: include not-cancel.h.
	(_dl_debug_vdprintf): Use writev_not_cancel_no_status instead
	of __writev or INTERNAL_SYSCALL.

--- a/elf/dl-misc.c
+++ b/elf/dl-misc.c
@@ -33,6 +33,7 @@
 #include <sysdep.h>
 #include <stdio-common/_itoa.h>
 #include <bits/libc-lock.h>
+#include <not-cancel.h>
 
 /* Read the whole contents of FILE into new mmap'd space with given
    protections.  *SIZEP gets the size of the file.  On error MAP_FAILED
@@ -236,24 +237,21 @@ _dl_debug_vdprintf (int fd, int tag_p, const char *fmt, va_list arg)
     }
 
   /* Finally write the result.  */
-#ifdef HAVE_INLINED_SYSCALLS
-  INTERNAL_SYSCALL_DECL (err);
-  INTERNAL_SYSCALL (writev, err, 3, fd, &iov, niov);
-#elif RTLD_PRIVATE_ERRNO
+#if !defined(HAVE_INLINED_SYSCALLS) && RTLD_PRIVATE_ERRNO
   /* We have to take this lock just to be sure we don't clobber the private
      errno when it's being used by another thread that cares about it.
      Yet we must be sure not to try calling the lock functions before
      the thread library is fully initialized.  */
   if (__builtin_expect (INTUSE (_dl_starting_up), 0))
-    __writev (fd, iov, niov);
+    writev_not_cancel_no_status(fd, iov, niov);
   else
     {
       __rtld_lock_lock_recursive (GL(dl_load_lock));
-      __writev (fd, iov, niov);
+      writev_not_cancel_no_status(fd, iov, niov);
       __rtld_lock_unlock_recursive (GL(dl_load_lock));
     }
 #else
-  __writev (fd, iov, niov);
+  writev_not_cancel_no_status(fd, iov, niov);
 #endif
 }
 
