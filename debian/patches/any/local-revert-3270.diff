Revert PR ntpl/3270

--- a/nptl/init.c	(revision 5285)
+++ b/nptl/init.c	(revision 5284)
@@ -221,21 +221,12 @@
 
   /* Reset the SETXID flag.  */
   struct pthread *self = THREAD_SELF;
-  int flags, newval;
-  do
-    {
-      flags = THREAD_GETMEM (self, cancelhandling);
-      newval = THREAD_ATOMIC_CMPXCHG_VAL (self, cancelhandling,
-					  flags & ~SETXID_BITMASK, flags);
-    }
-  while (flags != newval);
+  int flags = THREAD_GETMEM (self, cancelhandling);
+  THREAD_SETMEM (self, cancelhandling, flags & ~SETXID_BITMASK);
 
   /* And release the futex.  */
   self->setxid_futex = 1;
   lll_futex_wake (&self->setxid_futex, 1, LLL_PRIVATE);
-
-  if (atomic_decrement_val (&__xidcmd->cntr) == 0)
-    lll_futex_wake (&__xidcmd->cntr, 1, LLL_PRIVATE);
 }
 
 
--- a/nptl/allocatestack.c	(revision 5285)
+++ b/nptl/allocatestack.c	(revision 5284)
@@ -904,54 +904,23 @@
 
 static void
 internal_function
-setxid_mark_thread (struct xid_command *cmdp, struct pthread *t)
+setxid_signal_thread (struct xid_command *cmdp, struct pthread *t)
 {
-  int ch;
-
-  /* Don't let the thread exit before the setxid handler runs.  */
-  t->setxid_futex = 0;
-
-  do
+  if (! IS_DETACHED (t))
     {
-      ch = t->cancelhandling;
+      int ch;
+      do
+	{
+	  ch = t->cancelhandling;
 
-      /* If the thread is exiting right now, ignore it.  */
-      if ((ch & EXITING_BITMASK) != 0)
-	return;
+	  /* If the thread is exiting right now, ignore it.  */
+	  if ((ch & EXITING_BITMASK) != 0)
+	    return;
+	}
+      while (atomic_compare_and_exchange_bool_acq (&t->cancelhandling,
+						   ch | SETXID_BITMASK, ch));
     }
-  while (atomic_compare_and_exchange_bool_acq (&t->cancelhandling,
-					       ch | SETXID_BITMASK, ch));
-}
 
-
-static void
-internal_function
-setxid_unmark_thread (struct xid_command *cmdp, struct pthread *t)
-{
-  int ch;
-
-  do
-    {
-      ch = t->cancelhandling;
-      if ((ch & SETXID_BITMASK) == 0)
-	return;
-    }
-  while (atomic_compare_and_exchange_bool_acq (&t->cancelhandling,
-					       ch & ~SETXID_BITMASK, ch));
-
-  /* Release the futex just in case.  */
-  t->setxid_futex = 1;
-  lll_futex_wake (&t->setxid_futex, 1, LLL_PRIVATE);
-}
-
-
-static int
-internal_function
-setxid_signal_thread (struct xid_command *cmdp, struct pthread *t)
-{
-  if ((t->cancelhandling & SETXID_BITMASK) == 0)
-    return 0;
-
   int val;
   INTERNAL_SYSCALL_DECL (err);
 #if __ASSUME_TGKILL
@@ -967,14 +936,8 @@
     val = INTERNAL_SYSCALL (tkill, err, 2, t->tid, SIGSETXID);
 #endif
 
-  /* If this failed, it must have had not started yet or else exited.  */
   if (!INTERNAL_SYSCALL_ERROR_P (val, err))
-    {
-      atomic_increment (&cmdp->cntr);
-      return 1;
-    }
-  else
-    return 0;
+    atomic_increment (&cmdp->cntr);
 }
 
 
@@ -982,7 +945,6 @@
 attribute_hidden
 __nptl_setxid (struct xid_command *cmdp)
 {
-  int signalled;
   int result;
   lll_lock (stack_cache_lock, LLL_PRIVATE);
 
@@ -999,7 +961,7 @@
       if (t == self)
 	continue;
 
-      setxid_mark_thread (cmdp, t);
+      setxid_signal_thread (cmdp, t);
     }
 
   /* Now the list with threads using user-allocated stacks.  */
@@ -1009,63 +971,16 @@
       if (t == self)
 	continue;
 
-      setxid_mark_thread (cmdp, t);
+      setxid_signal_thread (cmdp, t);
     }
 
-  /* Iterate until we don't succeed in signalling anyone.  That means
-     we have gotten all running threads, and their children will be
-     automatically correct once started.  */
-  do
+  int cur = cmdp->cntr;
+  while (cur != 0)
     {
-      signalled = 0;
-
-      list_for_each (runp, &stack_used)
-	{
-	  struct pthread *t = list_entry (runp, struct pthread, list);
-	  if (t == self)
-	    continue;
-
-	  signalled += setxid_signal_thread (cmdp, t);
-	}
-
-      list_for_each (runp, &__stack_user)
-	{
-	  struct pthread *t = list_entry (runp, struct pthread, list);
-	  if (t == self)
-	    continue;
-
-	  signalled += setxid_signal_thread (cmdp, t);
-	}
-
-      int cur = cmdp->cntr;
-      while (cur != 0)
-	{
-	  lll_futex_wait (&cmdp->cntr, cur, LLL_PRIVATE);
-	  cur = cmdp->cntr;
-	}
+      lll_futex_wait (&cmdp->cntr, cur, LLL_PRIVATE);
+      cur = cmdp->cntr;
     }
-  while (signalled != 0);
 
-  /* Clean up flags, so that no thread blocks during exit waiting
-     for a signal which will never come.  */
-  list_for_each (runp, &stack_used)
-    {
-      struct pthread *t = list_entry (runp, struct pthread, list);
-      if (t == self)
-	continue;
-
-      setxid_unmark_thread (cmdp, t);
-    }
-
-  list_for_each (runp, &__stack_user)
-    {
-      struct pthread *t = list_entry (runp, struct pthread, list);
-      if (t == self)
-	continue;
-
-      setxid_unmark_thread (cmdp, t);
-    }
-
   /* This must be last, otherwise the current thread might not have
      permissions to send SIGSETXID syscall to the other threads.  */
   INTERNAL_SYSCALL_DECL (err);
