--- glibc-2.3.6/elf/ldconfig.c.orig	2005-02-16 11:29:34.000000000 +0100
+++ glibc-2.3.6/elf/ldconfig.c	2006-03-26 23:37:33.665182082 +0200
@@ -1027,6 +1027,125 @@
   fclose (file);
 }
 
+static void
+add_multiarch_dirs (const char *path)
+{
+  DIR *dir;
+  struct dirent64 *direntry;
+  char *file_name, *dir_name, *real_file_name, *link_path;
+  int file_name_len, real_file_name_len, link_path_len, len;
+  struct stat64 lstat_buf, stat_buf;
+  int is_link, is_dir;
+
+  file_name_len = PATH_MAX;
+  file_name = alloca (file_name_len);
+  
+  link_path_len = PATH_MAX;
+  link_path = alloca (link_path_len);
+ 
+  if (opt_chroot)
+    {
+      dir_name = chroot_canon (opt_chroot, path);
+      real_file_name_len = PATH_MAX;
+      real_file_name = alloca (real_file_name_len);
+    }
+  else
+    {
+      dir_name = xstrdup(path);
+      real_file_name_len = 0;
+      real_file_name = file_name;
+    }
+
+  if (dir_name == NULL || (dir = opendir (dir_name)) == NULL)
+    {
+      if (opt_verbose)
+        error (0, errno, _("Can't open directory %s"), path);
+      if (opt_chroot && dir_name)
+        free (dir_name);
+      return;
+    }
+
+  while ((direntry = readdir64 (dir)) != NULL)
+    {
+#ifdef _DIRENT_HAVE_D_TYPE
+      /* We only look at links.  */
+      if (direntry->d_type != DT_UNKNOWN && direntry->d_type != DT_LNK)
+	continue;
+#endif /* _DIRENT_HAVE_D_TYPE  */
+    
+      len = strlen (path) + strlen (direntry->d_name);
+      if (len > file_name_len)
+	{
+	  file_name_len = len + 1;
+	  file_name = alloca (file_name_len);
+	  if (!opt_chroot)
+	    real_file_name = file_name;
+	}
+      sprintf (file_name, "%s/%s", path, direntry->d_name);
+      if (opt_chroot)
+        {
+          len = strlen (dir_name) + strlen (direntry->d_name);
+          if (len > real_file_name_len)
+            {
+              real_file_name_len = len + 1;
+              real_file_name = alloca (real_file_name_len);
+            }
+          sprintf (real_file_name, "%s/%s", dir_name, direntry->d_name);
+        }
+
+      if (__builtin_expect (lstat64 (real_file_name, &lstat_buf), 0))
+        {
+          error (0, errno, _("Cannot lstat %s"), file_name);
+          continue;
+        }
+
+      /* We only look at links.  */
+      is_link = S_ISLNK (lstat_buf.st_mode);
+      if (!is_link)
+          continue;
+
+      /* Check the symlink refers to a directory.  */
+      if (__builtin_expect (stat64 (real_file_name, &stat_buf), 0))
+        {
+	  if (opt_verbose)
+	    error (0, errno, _("Cannot stat %s"), file_name);
+          continue;
+        }
+
+      is_dir = S_ISDIR (stat_buf.st_mode);
+      if (!is_dir)
+        {
+	  if (opt_verbose)
+	    error (0, errno, _("%s is not a directory"), file_name);
+          continue;
+        }
+
+      /* Read the link.  */
+      if (realpath(real_file_name, link_path) == NULL)
+	{
+	  if (opt_verbose)
+	    error (0, errno, _("Cannot read link %s"), file_name);
+          continue;
+	}
+
+      if (opt_chroot)
+	{
+	   len = strlen(opt_chroot);
+	   if (strncmp(opt_chroot, link_path, len) == 0)
+	     add_dir(link_path + len);		  
+	   else
+	     error (0, errno, _("Link %s refers to outside of the chroot"), file_name);
+	}
+      else
+	{	      
+          add_dir(link_path);
+	}	 
+    }
+
+  closedir (dir);
+  free (dir_name);
+}
+
 /* Handle one word in an `include' line, a glob pattern of additional
    config files to read.  */
 static void
@@ -1215,6 +1334,9 @@
       add_system_dir (SLIBDIR);
       if (strcmp (SLIBDIR, LIBDIR))
 	add_system_dir (LIBDIR);
+
+      /* Add multiarch directories.  */
+      add_multiarch_dirs("/lib/ldconfig");
     }
 
   search_dirs ();
