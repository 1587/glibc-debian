# DP: Description: Fix build when TLS is not available.
# DP: Upstream status: Submitted parts have been rejected. Parts 
                       submitted would very probably be rejected.

2007-02-09  Aurelien Jarno  <aurelien@aurel32.net>

        resolv/gai_sigqueue.c: Include <pthread.h>.

2007-02-06  Petr Salinger  <petr.salinger@seznam.cz>

        inet/inet_ntoa.c: Only use __thread if USE___THREAD.

2005-08-28  Thomas Schwinge  <schwinge@nic-nac-project.de>

	malloc/memusage.c: Only use __thread if USE___THREAD.


Index: malloc/memusage.c
===================================================================
RCS file: /cvs/glibc/libc/malloc/memusage.c,v
retrieving revision 1.12
diff -u -r1.12 memusage.c
--- malloc/memusage.c	20 Aug 2005 01:12:37 -0000	1.12
+++ malloc/memusage.c	27 Aug 2005 23:43:02 -0000
@@ -83,7 +83,11 @@
 static memusage_cntr_t decreasing_mremap;
 static memusage_size_t current_heap;
 static memusage_size_t peak_use[3];
+#if USE___THREAD
 static __thread uintptr_t start_sp;
+#else
+static uintptr_t start_sp;
+#endif
 
 /* A few macros to make the source more readable.  */
 #define peak_heap	peak_use[0]
--- inet/inet_ntoa.c	2006-04-09 07:50:08.000000000 +0200
+++ inet/inet_ntoa.c	2007-02-06 22:59:37.000000000 +0100
@@ -21,10 +21,14 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <arpa/inet.h>
+#include <tls.h>
 
 /* The interface of this function is completely stupid, it requires a
    static buffer.  We relax this a bit in that we allow one buffer for
    each thread.  */
+   
+#if USE_TLS && HAVE___THREAD
+
 static __thread char buffer[18];
 
 
@@ -37,3 +41,83 @@
 
   return buffer;
 }
+
+#else
+#include <bits/libc-lock.h>
+
+/* The interface of this function is completely stupid, it requires a
+   static buffer.  We relax this a bit in that we allow at least one
+   buffer for each thread.  */
+
+/* This is the key for the thread specific memory.  */
+static __libc_key_t key;
+
+/* If nonzero the key allocation failed and we should better use a
+   static buffer than fail.  */
+static char local_buf[18];
+static char *static_buf;
+
+/* Destructor for the thread-specific data.  */
+static void init (void);
+static void free_key_mem (void *mem);
+
+
+char *
+inet_ntoa (struct in_addr in)
+{
+  __libc_once_define (static, once);
+  char *buffer;
+  unsigned char *bytes;
+
+  /* If we have not yet initialized the buffer do it now.  */
+  __libc_once (once, init);
+
+  if (static_buf != NULL)
+    buffer = static_buf;
+  else
+    {
+      /* We don't use the static buffer and so we have a key.  Use it
+	 to get the thread-specific buffer.  */
+      buffer = __libc_getspecific (key);
+      if (buffer == NULL)
+	{
+	  /* No buffer allocated so far.  */
+	  buffer = malloc (18);
+	  if (buffer == NULL)
+	    /* No more memory available.  We use the static buffer.  */
+	    buffer = local_buf;
+	  else
+	    __libc_setspecific (key, buffer);
+	}
+    }
+
+  bytes = (unsigned char *) &in;
+  __snprintf (buffer, 18, "%d.%d.%d.%d",
+	      bytes[0], bytes[1], bytes[2], bytes[3]);
+
+  return buffer;
+}
+
+
+/* Initialize buffer.  */
+static void
+init (void)
+{
+  if (__libc_key_create (&key, free_key_mem))
+    /* Creating the key failed.  This means something really went
+       wrong.  In any case use a static buffer which is better than
+       nothing.  */
+    static_buf = local_buf;
+}
+
+
+/* Free the thread specific data, this is done if a thread terminates.  */
+static void
+free_key_mem (void *mem)
+{
+  free (mem);
+  __libc_setspecific (key, NULL);
+}
+
+#endif
+
--- resolv/gai_sigqueue.c	2007-02-09 20:15:02.000000000 +0100
+++ resolv/gai_sigqueue.c	2007-02-09 20:16:02.000000000 +0100
@@ -19,6 +19,7 @@
 #include <aio.h>
 #include <errno.h>
 #include <signal.h>
+#include <pthread.h>
 
 #include <gai_misc.h>
 
