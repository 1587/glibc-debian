Index: eglibc-2.17/libpthread/pthread/pt-create.c
===================================================================
--- eglibc-2.17.orig/libpthread/pthread/pt-create.c	2013-10-24 01:17:11.000000000 +0000
+++ eglibc-2.17/libpthread/pthread/pt-create.c	2013-10-24 01:17:11.000000000 +0000
@@ -112,11 +112,12 @@
   /* Find a stack.  There are several scenarios: if a detached thread
      kills itself, it has no way to deallocate its stack, thus it
      leaves PTHREAD->stack set to true.  We try to reuse it here,
-     however, if the user supplied a stack, we cannot use the old one.
-     Right now, we simply deallocate it.  */
+     however, if the user supplied a stack or changes the size,
+     we cannot use the old one.  Right now, we simply deallocate it.  */
   if (pthread->stack)
     {
-      if (setup->stackaddr != __pthread_default_attr.stackaddr)
+      if ((setup->stackaddr && setup->stackaddr != pthread->stackaddr)
+       || (setup->stacksize != pthread->stacksize))
 	{
 	  __pthread_stack_dealloc (pthread->stackaddr,
 				   pthread->stacksize);
@@ -126,13 +127,19 @@
     }
   else
     {
-      err = __pthread_stack_alloc (&pthread->stackaddr,
-				   setup->stacksize);
-      if (err)
-	goto failed_stack_alloc;
-
       pthread->stacksize = setup->stacksize;
-      pthread->stack = 1;
+
+      if (setup->stackaddr)
+	pthread->stackaddr = setup->stackaddr;
+      else
+	{
+	  err = __pthread_stack_alloc (&pthread->stackaddr,
+				       setup->stacksize);
+	  if (err)
+	    goto failed_stack_alloc;
+
+	  pthread->stack = 1;
+	}
     }
 
   /* Allocate the kernel thread and other required resources.  */
Index: eglibc-2.17/libpthread/pthread/pt-detach.c
===================================================================
--- eglibc-2.17.orig/libpthread/pthread/pt-detach.c	2013-10-24 01:17:11.000000000 +0000
+++ eglibc-2.17/libpthread/pthread/pt-detach.c	2013-10-24 01:17:11.000000000 +0000
@@ -66,9 +66,11 @@
 
       /* Destroy the stack, the kernel resources and the control
 	 block.  */
-      assert (pthread->stack);
-      __pthread_stack_dealloc (pthread->stackaddr, pthread->stacksize);
-      pthread->stack = 0;
+      if (pthread->stack)
+	{
+	  __pthread_stack_dealloc (pthread->stackaddr, pthread->stacksize);
+	  pthread->stack = 0;
+	}
 
       __pthread_thread_dealloc (pthread);
 
Index: eglibc-2.17/libpthread/pthread/pt-join.c
===================================================================
--- eglibc-2.17.orig/libpthread/pthread/pt-join.c	2013-10-24 01:17:11.000000000 +0000
+++ eglibc-2.17/libpthread/pthread/pt-join.c	2013-10-24 01:17:11.000000000 +0000
@@ -64,9 +64,11 @@
 
       /* Destroy the stack, the kernel resources and the control
 	 block.  */
-      assert (pthread->stack);
-      __pthread_stack_dealloc (pthread->stackaddr, pthread->stacksize);
-      pthread->stack = 0;
+      if (pthread->stack)
+	{
+	  __pthread_stack_dealloc (pthread->stackaddr, pthread->stacksize);
+	  pthread->stack = 0;
+	}
 
       __pthread_thread_dealloc (pthread);
 
Index: eglibc-2.17/libpthread/sysdeps/generic/pt-attr-setstacksize.c
===================================================================
--- eglibc-2.17.orig/libpthread/sysdeps/generic/pt-attr-setstacksize.c	2013-10-24 01:17:11.000000000 +0000
+++ eglibc-2.17/libpthread/sysdeps/generic/pt-attr-setstacksize.c	2013-10-24 01:17:11.000000000 +0000
@@ -24,18 +24,13 @@
 pthread_attr_setstacksize (pthread_attr_t *attr,
 			   size_t stacksize)
 {
-  if (stacksize == __pthread_default_attr.stacksize)
-    {
-      attr->stacksize = stacksize;
+  attr->stacksize = stacksize;
 
-      /* The guard size cannot be larger than the stack itself, as
-	 such, if the new stack size is smaller than the guard size,
-	 we squash the guard size.  */
-      if (attr->guardsize > attr->stacksize)
-	attr->guardsize = attr->stacksize;
+  /* The guard size cannot be larger than the stack itself, as
+     such, if the new stack size is smaller than the guard size,
+     we squash the guard size.  */
+  if (attr->guardsize > attr->stacksize)
+    attr->guardsize = attr->stacksize;
 
-      return 0;
-    }
-
-  return ENOTSUP;
+  return 0;
 }
Index: eglibc-2.17/libpthread/sysdeps/mach/hurd/ia32/pt-setup.c
===================================================================
--- eglibc-2.17.orig/libpthread/sysdeps/mach/hurd/ia32/pt-setup.c	2013-10-24 01:17:11.000000000 +0000
+++ eglibc-2.17/libpthread/sysdeps/mach/hurd/ia32/pt-setup.c	2013-10-24 01:17:11.000000000 +0000
@@ -32,13 +32,7 @@
     -----------------
    |  0              |
     -----------------
-   |                 |
-   |  Fast TSD       |
-   |                 |
-    -----------------
-
-    We need to reserve __hurd_threadvar_max `unsigned long int's' of
-    (fast) thread-specific data (TSD) for the Hurd.  */
+ */
 
 /* Set up the stack for THREAD, such that it appears as if
    START_ROUTINE and ARG were passed to the new thread's entry-point.
@@ -54,9 +48,6 @@
   bottom = thread->stackaddr;
   top = (uintptr_t *) ((uintptr_t) bottom + thread->stacksize);
 
-  /* Next, make room for the TSDs.  */
-  top -= __hurd_threadvar_max;
-
   if (start_routine)
     {
       /* And then the call frame.  */
Index: eglibc-2.17/libpthread/sysdeps/mach/hurd/pt-attr-setstackaddr.c
===================================================================
--- eglibc-2.17.orig/libpthread/sysdeps/mach/hurd/pt-attr-setstackaddr.c	2013-10-24 01:17:11.000000000 +0000
+++ eglibc-2.17/libpthread/sysdeps/mach/hurd/pt-attr-setstackaddr.c	2013-10-24 01:17:11.000000000 +0000
@@ -20,16 +20,10 @@
 #include <pthread.h>
 #include <pt-internal.h>
 
-/* We use fixed sized stacks which require proper alignment.  */
-#define __pthread_stacksize __pthread_default_attr.stacksize
-
 int
 pthread_attr_setstackaddr (pthread_attr_t *attr,
 			   void *stackaddr)
 {
-  if ((long) stackaddr & (__pthread_stacksize - 1))
-    return EINVAL;
-
   attr->stackaddr = stackaddr;
   return 0;
 }
Index: eglibc-2.17/libpthread/sysdeps/mach/hurd/pt-attr-setstacksize.c
===================================================================
--- eglibc-2.17.orig/libpthread/sysdeps/mach/hurd/pt-attr-setstacksize.c	2013-10-24 01:17:11.000000000 +0000
+++ eglibc-2.17/libpthread/sysdeps/mach/hurd/pt-attr-setstacksize.c	2013-10-24 01:17:11.000000000 +0000
@@ -20,16 +20,10 @@
 #include <pthread.h>
 #include <pt-internal.h>
 
-/* We use fixed sized stacks which require proper alignment.  */
-#define __pthread_stacksize __pthread_default_attr.stacksize
-
 int
 pthread_attr_setstacksize (pthread_attr_t *attr,
 			   size_t stacksize)
 {
-  if (stacksize != __pthread_stacksize)
-    return EINVAL;
-
   attr->stacksize = stacksize;
   return 0;
 }
diff --git a/libpthread/sysdeps/mach/hurd/pt-sigstate-init.c b/libpthread/sysdeps/mach/hurd/pt-sigstate-init.c
index da5a945..dd56d90 100644
--- a/libpthread/sysdeps/mach/hurd/pt-sigstate-init.c
+++ b/libpthread/sysdeps/mach/hurd/pt-sigstate-init.c
@@ -18,22 +18,12 @@
    Boston, MA 02111-1307, USA.  */
 
 #include <pthread.h>
-#include <hurd/threadvar.h>
 #include <hurd/signal.h>
-
 #include <pt-internal.h>
 
 error_t
 __pthread_sigstate_init (struct __pthread *thread)
 {
-  void **location =
-    (void *) __hurd_threadvar_location_from_sp (_HURD_THREADVAR_SIGSTATE,
-						thread->stackaddr);
-
-  /* The real initialization happens internally in glibc the first
-     time that _hurd_self_sigstate is called.  */
-  *location = 0;
-
   /* Mark the thread as a global signal receiver so as to conform with
      the pthread semantics.  However, we must be careful.  The first
      pthread created is the main thread, during libpthread initialization.
Index: eglibc-2.17/libpthread/sysdeps/mach/hurd/pt-sysdep.c
===================================================================
--- eglibc-2.17.orig/libpthread/sysdeps/mach/hurd/pt-sysdep.c	2013-10-24 01:17:11.000000000 +0000
+++ eglibc-2.17/libpthread/sysdeps/mach/hurd/pt-sysdep.c	2013-10-24 01:17:11.000000000 +0000
@@ -24,8 +24,6 @@
 #include <mach.h>
 #include <mach/mig_support.h>
 
-#include <hurd/threadvar.h>
-
 #include <pt-internal.h>
 
 /* Allow programs that know about this library to override the default stack
@@ -77,11 +75,5 @@
   /* Make MiG code thread aware.  */
   __mig_init (thread->stackaddr);
 
-  /* Make sure we can find the per-thread variables.  */
-  __hurd_threadvar_stack_mask = ~(__pthread_default_attr.stacksize - 1);
-  __hurd_threadvar_stack_offset
-    = (__pthread_default_attr.stacksize
-       - __hurd_threadvar_max * sizeof (uintptr_t));
-
   return thread->mcontext.sp;
 }
Index: eglibc-2.17/libpthread/sysdeps/mach/hurd/pt-sysdep.h
===================================================================
--- eglibc-2.17.orig/libpthread/sysdeps/mach/hurd/pt-sysdep.h	2013-10-24 01:17:11.000000000 +0000
+++ eglibc-2.17/libpthread/sysdeps/mach/hurd/pt-sysdep.h	2013-10-24 01:17:11.000000000 +0000
@@ -22,8 +22,6 @@
 
 #include <mach.h>
 
-#include <hurd/threadvar.h>
-
 /* XXX */
 #define _POSIX_THREAD_THREADS_MAX	64
 
Index: eglibc-2.17/libpthread/sysdeps/mach/pt-stack-alloc.c
===================================================================
--- eglibc-2.17.orig/libpthread/sysdeps/mach/pt-stack-alloc.c	2013-10-24 01:17:11.000000000 +0000
+++ eglibc-2.17/libpthread/sysdeps/mach/pt-stack-alloc.c	2013-10-24 01:17:11.000000000 +0000
@@ -24,8 +24,6 @@
 
 #include <pt-internal.h>
 
-#define __pthread_stacksize __pthread_default_attr.stacksize
-
 /* The next address to use for stack allocation.  */
 static vm_address_t next_stack_base = VM_MIN_ADDRESS;
 
@@ -41,16 +39,13 @@
   vm_offset_t base;
   int i = 0;
 
-  if (stacksize != __pthread_stacksize)
-    return EINVAL;
-
  get_stack:
   i ++;
   for (base = next_stack_base;
        base < VM_MAX_ADDRESS
 	 && __vm_allocate (__mach_task_self (), &base,
-			   __pthread_stacksize, FALSE) != KERN_SUCCESS;
-       base += __pthread_stacksize)
+			   stacksize, FALSE) != KERN_SUCCESS;
+       base += stacksize)
     ;
 
   if (base >= VM_MAX_ADDRESS)
@@ -67,7 +62,7 @@
   if (base >= VM_MAX_ADDRESS)
     return EAGAIN;
 
-  next_stack_base = base + __pthread_stacksize;
+  next_stack_base = base + stacksize;
 
   (*stackaddr) = (void *) base;
   return 0;
