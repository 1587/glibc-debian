commit 3410beff94994edf971dd634c56156d70c7cf215
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Sat Feb 28 21:41:47 2015 +0100

    Allow libpthread.so to dynamically loaded from a dlopened library
    
    * pthread/pt-internal.h: Include <ldsodefs.h>
    (_dl_allocate_tls, _dl_deallocate_tls): Remove declarations.
    * sysdeps/mach/hurd/pt-sysdep.c (init_routine): Rename into _init_routine,
    add `stack' parameter, return if __pthread_threads is already initialized,
    pass stack address to __pthread_create_internal if any.
    (init_routine): New function, calls init_routine with 0
    (dynamic_init_routine): New constructor function, calls init_routine with
    __libc_stack_end.

Index: glibc-2.19/libpthread/pthread/pt-internal.h
===================================================================
--- glibc-2.19.orig/libpthread/pthread/pt-internal.h
+++ glibc-2.19/libpthread/pthread/pt-internal.h
@@ -35,6 +35,10 @@
 #include <pt-sysdep.h>
 #include <pt-machdep.h>
 
+#ifdef IS_IN_libpthread
+# include <ldsodefs.h>
+#endif
+
 /* Thread state.  */
 enum pthread_state
 {
@@ -323,17 +327,4 @@ const struct __pthread_rwlockattr __pthr
 /* Default condition attributes.  */
 const struct __pthread_condattr __pthread_default_condattr;
 
-
-#ifdef ENABLE_TLS
-
-/* From glibc.  */
-
-/* Dynamic linker TLS allocation.  */
-extern void *_dl_allocate_tls(void *);
-
-/* Dynamic linker TLS deallocation.  */
-extern void _dl_deallocate_tls(void *, int);
-
-#endif /* ENABLE_TLS */
-
 #endif /* pt-internal.h */
Index: glibc-2.19/libpthread/sysdeps/mach/hurd/pt-sysdep.c
===================================================================
--- glibc-2.19.orig/libpthread/sysdeps/mach/hurd/pt-sysdep.c
+++ glibc-2.19/libpthread/sysdeps/mach/hurd/pt-sysdep.c
@@ -39,16 +39,31 @@ void *(*_cthread_init_routine)(void) = &
    should return a new stack pointer for the main thread.  The caller
    will switch to this new stack before doing anything serious.  */
 static void *
-init_routine (void)
+_init_routine (void *stack)
 {
   struct __pthread *thread;
   int err;
+  pthread_attr_t attr, *attrp = 0;
+
+  if (__pthread_threads)
+    /* Already initialized */
+    return 0;
 
   /* Initialize the library.  */
   __pthread_init ();
 
+  if (stack)
+    {
+      /* We are getting initialized due to dlopening a library using libpthread
+	 while the main program was not linked against libpthread.  */
+      /* Avoid allocating another stack */
+      attrp = &attr;
+      pthread_attr_init(attrp);
+      pthread_attr_setstack(attrp, __libc_stack_end, __vm_page_size);
+    }
+
   /* Create the pthread structure for the main thread (i.e. us).  */
-  err = __pthread_create_internal (&thread, 0, 0, 0);
+  err = __pthread_create_internal (&thread, attrp, 0, 0);
   assert_perror (err);
 
   /* XXX The caller copies the command line arguments and the environment
@@ -68,3 +83,16 @@ init_routine (void)
 
   return thread->mcontext.sp;
 }
+
+static void *
+init_routine (void)
+{
+  return _init_routine (0);
+}
+
+#ifdef SHARED
+__attribute__ ((constructor)) static void dynamic_init_routine(void)
+{
+  _init_routine (__libc_stack_end);
+}
+#endif
