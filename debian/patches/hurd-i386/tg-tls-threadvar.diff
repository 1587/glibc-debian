From: Thomas Schwinge <thomas@schwinge.name>
Subject: [PATCH] tls-threadvar

replace the custom threadvar mechanism with generic TLS.
That will fix sigaltstack.

---
 hurd/Versions                       |  3 ---
 hurd/hurd/signal.h                  | 23 +++++++++++++---------
 hurd/hurd/threadvar.h               |  3 +++
 hurd/hurdsig.c                      | 20 +++++++++++--------
 hurd/sigunwind.c                    |  3 +--
 include/errno.h                     |  2 +-
 sysdeps/mach/hurd/Versions          |  4 ++++
 sysdeps/mach/hurd/bits/libc-lock.h  |  5 +++--
 sysdeps/mach/hurd/bits/libc-tsd.h   | 34 --------------------------------
 sysdeps/mach/hurd/cthreads.c        |  3 +++
 sysdeps/mach/hurd/dl-sysdep.c       |  4 ----
 sysdeps/mach/hurd/errno-loc.c       | 24 +++++++++++++++--------
 sysdeps/mach/hurd/errno.c           |  1 -
 sysdeps/mach/hurd/i386/init-first.c |  1 -
 sysdeps/mach/hurd/i386/sigreturn.c  |  3 +--
 sysdeps/mach/hurd/i386/tls.h        | 26 +++++++++++++++++++++++++
 sysdeps/mach/hurd/mig-reply.c       | 39 ++++++++++---------------------------
 sysdeps/mach/hurd/tls.h             |  1 +
 18 files changed, 95 insertions(+), 104 deletions(-)

diff --git a/hurd/Versions b/hurd/Versions
index 83c8ab1..2264faf 100644
--- a/hurd/Versions
+++ b/hurd/Versions
@@ -36,9 +36,6 @@ libc {
     __hurd_threadvar_max;
     __hurd_threadvar_stack_mask; __hurd_threadvar_stack_offset;
 
-    # functions used in macros & inline functions
-    __hurd_errno_location;
-
     # functions used in libmachuser and libhurduser
     _S_catch_exception_raise;
     _S_catch_exception_raise_state;
diff --git a/hurd/hurd/signal.h b/hurd/hurd/signal.h
index d4079ef..1efa4a2 100644
--- a/hurd/hurd/signal.h
+++ b/hurd/hurd/signal.h
@@ -129,14 +129,13 @@ extern struct hurd_sigstate *_hurd_self_sigstate (void)
 #define _HURD_SIGNAL_H_EXTERN_INLINE __extern_inline
 #endif
 
+extern __thread struct hurd_sigstate *_hurd_sigstate;
 _HURD_SIGNAL_H_EXTERN_INLINE struct hurd_sigstate *
 _hurd_self_sigstate (void)
 {
-  struct hurd_sigstate **location =
-    (void *) __hurd_threadvar_location (_HURD_THREADVAR_SIGSTATE);
-  if (*location == NULL)
-    *location = _hurd_thread_sigstate (__mach_thread_self ());
-  return *location;
+  if (_hurd_sigstate == NULL)
+    _hurd_sigstate = _hurd_thread_sigstate (__mach_thread_self ());
+  return _hurd_sigstate;
 }
 
 /* Thread listening on our message port; also called the "signal thread".  */
@@ -167,16 +166,22 @@ extern int _hurd_core_limit;
 _HURD_SIGNAL_H_EXTERN_INLINE void *
 _hurd_critical_section_lock (void)
 {
-  struct hurd_sigstate **location =
-    (void *) __hurd_threadvar_location (_HURD_THREADVAR_SIGSTATE);
-  struct hurd_sigstate *ss = *location;
+  struct hurd_sigstate *ss;
+
+#ifdef __LIBC_NO_TLS
+  if (__LIBC_NO_TLS())
+    /* TLS is currently initializing, no need to enter critical section.  */
+    return NULL;
+#endif
+
+  ss = _hurd_sigstate;
   if (ss == NULL)
     {
       /* The thread variable is unset; this must be the first time we've
 	 asked for it.  In this case, the critical section flag cannot
 	 possible already be set.  Look up our sigstate structure the slow
 	 way; this locks the sigstate lock.  */
-      ss = *location = _hurd_thread_sigstate (__mach_thread_self ());
+      ss = _hurd_sigstate = _hurd_thread_sigstate (__mach_thread_self ());
       __spin_unlock (&ss->lock);
     }
 
diff --git a/hurd/hurd/threadvar.h b/hurd/hurd/threadvar.h
index 786db14..d5dd141 100644
--- a/hurd/hurd/threadvar.h
+++ b/hurd/hurd/threadvar.h
@@ -20,6 +20,7 @@
 #define	_HURD_THREADVAR_H
 
 #include <features.h>
+#include <tls.h>
 
 /* The per-thread variables are found by ANDing this mask
    with the value of the stack pointer and then adding this offset.
@@ -112,5 +113,7 @@ __hurd_threadvar_location (enum __hurd_threadvar_index __index)
 					    __thread_stack_pointer ());
 }
 
+extern mach_port_t __hurd_reply_port0;
+#define __hurd_local_reply_port (*(__LIBC_NO_TLS() ? &__hurd_reply_port0 : &THREAD_SELF->reply_port))
 
 #endif	/* hurd/threadvar.h */
diff --git a/hurd/hurdsig.c b/hurd/hurdsig.c
index 8e912db..ee4227a 100644
--- a/hurd/hurdsig.c
+++ b/hurd/hurdsig.c
@@ -50,6 +50,9 @@ unsigned long int __hurd_sigthread_stack_base;
 unsigned long int __hurd_sigthread_stack_end;
 unsigned long int *__hurd_sigthread_variables;
 
+/* Per-thread signal state.  */
+__thread struct hurd_sigstate *_hurd_sigstate;
+
 /* Linked-list of per-thread signal state.  */
 struct hurd_sigstate *_hurd_sigstates;
 
@@ -234,11 +237,11 @@ abort_thread (struct hurd_sigstate *ss, struct machine_thread_all_state *state,
    that this location can be set without faulting, or else return NULL.  */
 
 static mach_port_t *
-interrupted_reply_port_location (struct machine_thread_all_state *thread_state,
+interrupted_reply_port_location (thread_t thread,
+				 struct machine_thread_all_state *thread_state,
 				 int sigthread)
 {
-  mach_port_t *portloc = (mach_port_t *) __hurd_threadvar_location_from_sp
-    (_HURD_THREADVAR_MIG_REPLY, (void *) thread_state->basic.SP);
+  mach_port_t *portloc = &THREAD_TCB(thread, thread_state)->reply_port;
 
   if (sigthread && _hurdsig_catch_memory_fault (portloc))
     /* Faulted trying to read the stack.  */
@@ -323,7 +326,8 @@ _hurdsig_abort_rpcs (struct hurd_sigstate *ss, int signo, int sigthread,
 	   our nonzero return tells the trampoline code to finish the message
 	   receive operation before running the handler.  */
 
-	mach_port_t *reply = interrupted_reply_port_location (state,
+	mach_port_t *reply = interrupted_reply_port_location (ss->thread,
+							      state,
 							      sigthread);
 	error_t err = __interrupt_operation (intr_port, _hurdsig_interrupt_timeout);
 
@@ -835,7 +839,8 @@ _hurd_internal_post_signal (struct hurd_sigstate *ss,
 
 	    if (! machine_get_basic_state (ss->thread, &thread_state))
 	      goto sigbomb;
-	    loc = interrupted_reply_port_location (&thread_state, 1);
+	    loc = interrupted_reply_port_location (ss->thread,
+						   &thread_state, 1);
 	    if (loc && *loc != MACH_PORT_NULL)
 	      /* This is the reply port for the context which called
 		 sigreturn.  Since we are abandoning that context entirely
@@ -901,7 +906,8 @@ _hurd_internal_post_signal (struct hurd_sigstate *ss,
 	{
 	  /* Fetch the thread variable for the MiG reply port,
 	     and set it to MACH_PORT_NULL.  */
-	  mach_port_t *loc = interrupted_reply_port_location (&thread_state,
+	  mach_port_t *loc = interrupted_reply_port_location (ss->thread,
+							      &thread_state,
 							      1);
 	  if (loc)
 	    {
@@ -1276,8 +1282,6 @@ _hurdsig_init (const int *intarray, size_t intarraysize)
 	__libc_fatal ("hurd: Can't allocate threadvars for signal thread\n");
       memset (__hurd_sigthread_variables, 0,
 	      __hurd_threadvar_max * sizeof (unsigned long int));
-      __hurd_sigthread_variables[_HURD_THREADVAR_LOCALE]
-	= (unsigned long int) &_nl_global_locale;
 
       /* Reinitialize the MiG support routines so they will use a per-thread
 	 variable for the cached reply port.  */
diff --git a/hurd/sigunwind.c b/hurd/sigunwind.c
index de966aa..40af749 100644
--- a/hurd/sigunwind.c
+++ b/hurd/sigunwind.c
@@ -38,8 +38,7 @@ _hurdsig_longjmp_from_handler (void *data, jmp_buf env, int val)
     {
       /* Destroy the MiG reply port used by the signal handler, and restore
 	 the reply port in use by the thread when interrupted.  */
-      mach_port_t *reply_port =
-	(mach_port_t *) __hurd_threadvar_location (_HURD_THREADVAR_MIG_REPLY);
+      mach_port_t *reply_port = &__hurd_local_reply_port;
       if (*reply_port)
 	{
 	  mach_port_t port = *reply_port;
diff --git a/include/errno.h b/include/errno.h
index effa593..5b75ffc 100644
--- a/include/errno.h
+++ b/include/errno.h
@@ -21,7 +21,7 @@ extern int rtld_errno attribute_hidden;
 
 #  include <tls.h>
 
-#  if !defined(__GNU__)
+#  if !(defined(__GNU__) && defined IS_IN_rtld)
 #   undef  errno
 #   ifndef NOT_IN_libc
 #    define errno __libc_errno
diff --git a/sysdeps/mach/hurd/Versions b/sysdeps/mach/hurd/Versions
index 89e1906..1f04244 100644
--- a/sysdeps/mach/hurd/Versions
+++ b/sysdeps/mach/hurd/Versions
@@ -6,6 +6,8 @@ libc {
   GLIBC_PRIVATE {
     # Functions shared with the dynamic linker
     __libc_read; __libc_write; __libc_lseek64;
+    __libc_lock_self0; __libc_lock_self;
+    _hurd_sigstate;
 
     _dl_init_first;
   }
@@ -33,5 +35,7 @@ ld {
 
     # functions that must be shared with libc
     __libc_read; __libc_write; __libc_lseek64;
+    __libc_lock_self0; __libc_lock_self;
+    _hurd_sigstate;
   }
 }
diff --git a/sysdeps/mach/hurd/bits/libc-lock.h b/sysdeps/mach/hurd/bits/libc-lock.h
index 8bf5656..9c25b4c 100644
--- a/sysdeps/mach/hurd/bits/libc-lock.h
+++ b/sysdeps/mach/hurd/bits/libc-lock.h
@@ -24,7 +24,6 @@
 #include <tls.h>
 #endif
 #include <cthreads.h>
-#include <hurd/threadvar.h>
 
 typedef struct mutex __libc_lock_t;
 typedef struct
@@ -35,7 +34,9 @@ typedef struct
 } __libc_lock_recursive_t;
 typedef __libc_lock_recursive_t __rtld_lock_recursive_t;
 
-#define __libc_lock_owner_self() ((void *) __hurd_threadvar_location (0))
+extern char __libc_lock_self0[0];
+extern __thread char __libc_lock_self[0];
+#define __libc_lock_owner_self() (__LIBC_NO_TLS() ? &__libc_lock_self0 : (void*) &__libc_lock_self)
 
 #else
 typedef struct __libc_lock_opaque__ __libc_lock_t;
diff --git a/sysdeps/mach/hurd/bits/libc-tsd.h b/sysdeps/mach/hurd/bits/libc-tsd.h
deleted file mode 100644
index d2480ed..0000000
--- a/sysdeps/mach/hurd/bits/libc-tsd.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/* libc-internal interface for thread-specific data.  Hurd version.
-   Copyright (C) 1998,2002,2008 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#ifndef _BITS_LIBC_TSD_H
-#define _BITS_LIBC_TSD_H 1
-
-#include <hurd/threadvar.h>
-
-#define __libc_tsd_define(CLASS, TYPE, KEY) /* nothing, always have threadvars */
-
-#define __libc_tsd_address(TYPE, KEY) \
-  ((TYPE *) __hurd_threadvar_location (_HURD_THREADVAR_##KEY))
-
-#define __libc_tsd_get(TYPE, KEY) \
-  (*__libc_tsd_address (TYPE, KEY))
-#define __libc_tsd_set(TYPE, KEY, VALUE) \
-  (*__libc_tsd_address (TYPE, KEY) = (VALUE))
-
-#endif	/* bits/libc-tsd.h */
diff --git a/sysdeps/mach/hurd/cthreads.c b/sysdeps/mach/hurd/cthreads.c
index 5b5ed51..2f140f9 100644
--- a/sysdeps/mach/hurd/cthreads.c
+++ b/sysdeps/mach/hurd/cthreads.c
@@ -19,6 +19,9 @@
 #include <errno.h>
 #include <stdlib.h>
 
+char __libc_lock_self0[0];
+__thread char __libc_lock_self[0];
+
 /* Placeholder for key creation routine from Hurd cthreads library.  */
 int
 weak_function
diff --git a/sysdeps/mach/hurd/dl-sysdep.c b/sysdeps/mach/hurd/dl-sysdep.c
index c9ab661..b5e7636 100644
--- a/sysdeps/mach/hurd/dl-sysdep.c
+++ b/sysdeps/mach/hurd/dl-sysdep.c
@@ -64,10 +64,6 @@ hp_timing_t _dl_cpuclock_offset;
 
 struct hurd_startup_data *_dl_hurd_data;
 
-/* This is used only within ld.so, via dl-minimal.c's __errno_location.  */
-#undef errno
-int errno attribute_hidden;
-
 /* Defining these variables here avoids the inclusion of hurdsig.c.  */
 unsigned long int __hurd_sigthread_stack_base;
 unsigned long int __hurd_sigthread_stack_end;
diff --git a/sysdeps/mach/hurd/errno-loc.c b/sysdeps/mach/hurd/errno-loc.c
index 73e5e79..fcca046 100644
--- a/sysdeps/mach/hurd/errno-loc.c
+++ b/sysdeps/mach/hurd/errno-loc.c
@@ -16,13 +16,21 @@
    License along with the GNU C Library; if not, see
    <http://www.gnu.org/licenses/>.  */
 
-#include <errno.h>
-#include <hurd/threadvar.h>
-
-int *
+#ifdef IS_IN_rtld
+/*
+ * rtld can not access TLS too early, thus rtld_errno.
+ *
+ * Instead of making __open/__close pass errno from TLS to rtld_errno, simply
+ * use a weak __errno_location using rtld_errno, which will be overriden by the
+ * libc definition.
+ */
+static int rtld_errno;
+int * weak_function
 __errno_location (void)
 {
-  return (int *) __hurd_threadvar_location (_HURD_THREADVAR_ERRNO);
+  return &rtld_errno;
 }
-strong_alias (__errno_location, __hurd_errno_location)
-libc_hidden_def (__errno_location)
+libc_hidden_weak (__errno_location)
+#else
+#include <../../../csu/errno-loc.c>
+#endif
diff --git a/sysdeps/mach/hurd/errno.c b/sysdeps/mach/hurd/errno.c
deleted file mode 100644
index a29091b..0000000
--- a/sysdeps/mach/hurd/errno.c
+++ /dev/null
@@ -1 +0,0 @@
-/* No definition of `errno' variable on the Hurd.  */
diff --git a/sysdeps/mach/hurd/i386/init-first.c b/sysdeps/mach/hurd/i386/init-first.c
index d1e3577..6cfbf48 100644
--- a/sysdeps/mach/hurd/i386/init-first.c
+++ b/sysdeps/mach/hurd/i386/init-first.c
@@ -162,7 +162,6 @@ init (int *data)
      for malloc et al, or so we can use malloc below for the real
      threadvars array.  */
   memset (threadvars, 0, sizeof threadvars);
-  threadvars[_HURD_THREADVAR_LOCALE] = (unsigned long int) &_nl_global_locale;
   __hurd_threadvar_stack_offset = (unsigned long int) threadvars;
 
   /* Since the cthreads initialization code uses malloc, and the
diff --git a/sysdeps/mach/hurd/i386/sigreturn.c b/sysdeps/mach/hurd/i386/sigreturn.c
index 92727b5..1953096 100644
--- a/sysdeps/mach/hurd/i386/sigreturn.c
+++ b/sysdeps/mach/hurd/i386/sigreturn.c
@@ -77,8 +77,7 @@ __sigreturn (struct sigcontext *scp)
 
   /* Destroy the MiG reply port used by the signal handler, and restore the
      reply port in use by the thread when interrupted.  */
-  reply_port =
-    (mach_port_t *) __hurd_threadvar_location (_HURD_THREADVAR_MIG_REPLY);
+  reply_port = &__hurd_local_reply_port;
   if (*reply_port)
     {
       mach_port_t port = *reply_port;
diff --git a/sysdeps/mach/hurd/i386/tls.h b/sysdeps/mach/hurd/i386/tls.h
index bf0cf43..7159484 100644
--- a/sysdeps/mach/hurd/i386/tls.h
+++ b/sysdeps/mach/hurd/i386/tls.h
@@ -53,6 +53,17 @@
       | (((unsigned int) (tcb)) & 0xff000000) /* base 24..31 */		      \
     }
 
+# define HURD_DESC_TLS(desc)						      \
+  ({									      \
+   (tcbhead_t *) (   (desc->low_word >> 16)				      \
+                  | ((desc->high_word & 0xff) << 16)			      \
+                  |  (desc->high_word & 0xff000000)			      \
+     );})
+
+#define __LIBC_NO_TLS()							      \
+  ({ unsigned short ds, gs;						      \
+     asm ("movw %%ds,%w0; movw %%gs,%w1" : "=q" (ds), "=q" (gs));	      \
+     ds == gs; })
 
 static inline const char * __attribute__ ((unused))
 _hurd_tls_init (tcbhead_t *tcb, int secondcall)
@@ -127,6 +138,21 @@ _hurd_tls_init (tcbhead_t *tcb, int secondcall)
 	      : "i" (offsetof (tcbhead_t, tcb)));			      \
      __tcb;})
 
+/* Return the TCB address of a thread given its state.  */
+# define THREAD_TCB(thread, thread_state)				      \
+  ({ int __sel = (thread_state)->basic.gs;				      \
+     tcbhead_t *__tcb;							      \
+     struct descriptor __desc, *___desc = &__desc;			      \
+     unsigned int __count = 1;						      \
+     kern_return_t __err;						      \
+     if (__builtin_expect (__sel, 0x48) & 4) /* LDT selector */		      \
+       __err = __i386_get_ldt ((thread), __sel, 1, &___desc, &__count);	      \
+     else								      \
+       __err = __i386_get_gdt ((thread), __sel, &__desc);		      \
+     assert_perror (__err);						      \
+     assert (__count == 1);						      \
+     HURD_DESC_TLS(___desc);})
+
 /* Install new dtv for current thread.  */
 # define INSTALL_NEW_DTV(dtvp)						      \
   ({ asm volatile ("movl %0,%%gs:%P1"					      \
diff --git a/sysdeps/mach/hurd/mig-reply.c b/sysdeps/mach/hurd/mig-reply.c
index f0b5172..1b3ff87 100644
--- a/sysdeps/mach/hurd/mig-reply.c
+++ b/sysdeps/mach/hurd/mig-reply.c
@@ -18,26 +18,20 @@
 #include <mach.h>
 #include <hurd/threadvar.h>
 
-#define GETPORT \
-  mach_port_t *portloc = \
-    (mach_port_t *) __hurd_threadvar_location (_HURD_THREADVAR_MIG_REPLY)
-#define reply_port (*(use_threadvar ? portloc : &global_reply_port))
-
-static int use_threadvar;
-static mach_port_t global_reply_port;
-
 /* These functions are called by MiG-generated code.  */
 
+mach_port_t __hurd_reply_port0;
+
 /* Called by MiG to get a reply port.  */
 mach_port_t
 __mig_get_reply_port (void)
 {
-  GETPORT;
-
-  if (reply_port == MACH_PORT_NULL)
-    reply_port = __mach_reply_port ();
+  if (__hurd_local_reply_port == MACH_PORT_NULL ||
+      (&__hurd_local_reply_port != &__hurd_reply_port0
+       && __hurd_local_reply_port == __hurd_reply_port0))
+    __hurd_local_reply_port = __mach_reply_port ();
 
-  return reply_port;
+  return __hurd_local_reply_port;
 }
 weak_alias (__mig_get_reply_port, mig_get_reply_port)
 
@@ -45,12 +39,8 @@ weak_alias (__mig_get_reply_port, mig_get_reply_port)
 void
 __mig_dealloc_reply_port (mach_port_t arg)
 {
-  mach_port_t port;
-
-  GETPORT;
-
-  port = reply_port;
-  reply_port = MACH_PORT_NULL;	/* So the mod_refs RPC won't use it.  */
+  mach_port_t port = __hurd_local_reply_port;
+  __hurd_local_reply_port = MACH_PORT_NULL;	/* So the mod_refs RPC won't use it.  */
 
   if (MACH_PORT_VALID (port))
     __mach_port_mod_refs (__mach_task_self (), port,
@@ -73,15 +63,6 @@ weak_alias (__mig_put_reply_port, mig_put_reply_port)
 void
 __mig_init (void *stack)
 {
-  use_threadvar = stack != 0;
-
-  if (use_threadvar)
-    {
-      /* Recycle the reply port used before multithreading was enabled.  */
-      mach_port_t *portloc = (mach_port_t *)
-	__hurd_threadvar_location_from_sp (_HURD_THREADVAR_MIG_REPLY, stack);
-      *portloc = global_reply_port;
-      global_reply_port = MACH_PORT_NULL;
-    }
+  /* Do nothing.  */
 }
 weak_alias (__mig_init, mig_init)
diff --git a/sysdeps/mach/hurd/tls.h b/sysdeps/mach/hurd/tls.h
index 230f907..a5f65ff 100644
--- a/sysdeps/mach/hurd/tls.h
+++ b/sysdeps/mach/hurd/tls.h
@@ -47,6 +47,7 @@ typedef struct
   void *tcb;			/* Points to this structure.  */
   dtv_t *dtv;			/* Vector of pointers to TLS data.  */
   thread_t self;		/* This thread's control port.  */
+  mach_port_t reply_port;	/* This thread's reply port.  */
 } tcbhead_t;
 
 
-- 
tg: (16304d6..) t/tls-threadvar (depends on: t/tls)
